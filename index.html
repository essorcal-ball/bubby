<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Stickman Jumper</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #1a1a2e; }
    .screen { display: none; height: 100vh; width: 100vw; transition: opacity 0.3s ease-in-out; box-sizing: border-box; }
    .main-button { transition: all 0.2s ease; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2), 0 2px 4px -2px rgba(0,0,0,0.1); }
    .main-button:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3), 0 4px 6px -4px rgba(0,0,0,0.2); }
    .main-button:active { transform: translateY(0); box-shadow: none; }
    #gameCanvas { background-color: #4a5568; border: 4px solid #e94560; border-radius: 12px; touch-action: manipulation; }
    .game-status-box { background-color: #16213e; border-radius: 8px; padding: 12px 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.4); }
    .shop-card { background-color: #16213e; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.4); transition: transform 0.1s; }
    .shop-card:hover { transform: translateY(-2px); border-color: #e94560; }
    .table-header { background-color: #1f2a44; }
    .table-row { background-color: #203463; }
    .table-row:nth-child(odd) { background-color: #1b2c4a; }
    .skin-preview { border: 1px solid #374151; border-radius: 6px; background: #111827; }
    .badge { font-size: 0.75rem; padding: 2px 8px; border-radius: 999px; display: inline-block; }
    .badge-not { background: #10b98122; color: #10b981; border: 1px solid #10b98155; }
    .badge-bad { background: #f59e0b22; color: #f59e0b; border: 1px solid #f59e0b55; }
    .badge-horrible { background: #ef444422; color: #ef4444; border: 1px solid #ef444455; }
    .badge-very { background: #7c3aed22; color: #7c3aed; border: 1px solid #7c3aed55; }
  </style>
</head>
<body class="flex items-center justify-center text-white">

  <div id="app-container" class="w-full h-full">

    <!-- Sticky Account Bar -->
    <div id="account-bar" class="fixed top-0 right-0 flex items-center space-x-4 bg-[#16213e] px-4 py-2 rounded-bl-lg shadow-lg z-50">
      <span class="text-yellow-400 font-semibold">
        Logged in as: <span id="current-username">Guest</span>
      </span>
      <button onclick="logoutAccount()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">Logout</button>
    </div>

    <!-- LOGIN SCREEN -->
    <div id="login-screen" class="screen flex flex-col items-center justify-center p-8">
      <h1 class="text-5xl font-extrabold text-[#e94560] mb-8">Welcome to Arcade Hero</h1>
      <div class="w-full max-w-sm space-y-4">
        <input id="username-input" type="text" placeholder="Enter Username" class="w-full p-3 rounded-lg text-black" />
        <div class="relative">
          <input id="password-input" type="password" placeholder="Enter Password" class="w-full p-3 rounded-lg text-black pr-12" />
          <button type="button" onclick="togglePassword('password-input')" class="absolute right-2 top-2 bg-gray-700 text-white px-2 py-1 rounded">Show</button>
        </div>
        <div class="relative">
          <input id="confirm-password-input" type="password" placeholder="Confirm Password" class="w-full p-3 rounded-lg text-black pr-12" />
          <button type="button" onclick="togglePassword('confirm-password-input')" class="absolute right-2 top-2 bg-gray-700 text-white px-2 py-1 rounded">Show</button>
        </div>
        <button onclick="createAccount()" class="main-button bg-green-600 text-white font-bold py-3 px-6 rounded-lg">Create Account</button>
        <button onclick="loginAccount()" class="main-button bg-blue-600 text-white font-bold py-3 px-6 rounded-lg">Login</button>
      </div>
    </div>

    <!-- MENU SCREEN -->
    <div id="menu-screen" class="screen flex flex-col items-center justify-center p-4">
      <h1 class="text-6xl md:text-8xl font-extrabold text-[#e94560] mb-12 animate-pulse tracking-widest">ARCADE HERO</h1>
      <div class="flex flex-col space-y-6 w-full max-w-sm">
        <button onclick="goToScreen('game')" class="main-button bg-[#16213e] text-3xl font-bold py-4 rounded-xl border-b-4 border-[#1c305c] hover:bg-[#203463]">PLAY GAME</button>
        <button onclick="goToScreen('shop')" class="main-button bg-[#16213e] text-3xl font-bold py-4 rounded-xl border-b-4 border-[#1c305c] hover:bg-[#203463]">SHOP</button>
        <button onclick="goToScreen('leaderboard')" class="main-button bg-[#16213e] text-3xl font-bold py-4 rounded-xl border-b-4 border-[#1c305c] hover:bg-[#203463]">LEADERBOARD</button>
      </div>
    </div>

    <!-- GAME SCREEN -->
    <div id="game-screen" class="screen flex flex-col items-center justify-start py-8 px-4">
      <div id="game-info" class="game-status-box flex justify-between w-full max-w-4xl mb-4">
        <span class="text-xl font-semibold">Score: <span id="current-score">0</span></span>
        <span class="text-xl font-semibold text-yellow-400">High Score: <span id="high-score">0</span></span>
        <span class="text-xl font-semibold text-yellow-400">üí∞ Coins: <span id="coin-count">0</span></span>
      </div>

      <canvas id="gameCanvas" class="w-full max-w-4xl h-96 md:h-[500px]"></canvas>

      <div id="game-controls" class="mt-6 flex flex-wrap justify-center gap-4">
        <button onclick="player?.jump()" id="jump-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-xl active:shadow-none transition duration-150">JUMP</button>
        <button id="crouch-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg shadow-xl active:shadow-none transition duration-150">CROUCH (ArrowDown/S)</button>

        <button id="hacker-button" onclick="activateHackerAbility()" class="main-button bg-purple-600 text-white font-bold py-3 px-8 rounded-lg relative overflow-hidden disabled:bg-gray-700 disabled:shadow-xl transition duration-150" disabled>
          <div id="hacker-cooldown-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height: 100%;"></div>
          <span id="hacker-cooldown-text" class="relative z-20 flex items-center justify-center font-extrabold text-lg text-white">BUY IN SHOP</span>
        </button>

        <button id="time-button" onclick="activateTimeAbility()" class="main-button bg-blue-600 text-white font-bold py-3 px-8 rounded-lg relative overflow-hidden disabled:bg-gray-700 disabled:shadow-xl transition duration-150" disabled>
          <div id="time-cooldown-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height: 100%;"></div>
          <span id="time-cooldown-text" class="relative z-20 flex items-center justify-center font-extrabold text-lg text-white">BUY TIME</span>
        </button>

        <button id="golden-hacker-button" onclick="activateGoldenHacker()" class="main-button bg-yellow-500 text-white font-bold py-3 px-8 rounded-lg relative overflow-hidden disabled:bg-gray-700 disabled:shadow-xl transition duration-150" disabled>
          <div id="golden-hacker-cooldown-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height: 100%;"></div>
          <span id="golden-hacker-cooldown-text" class="relative z-20 flex items-center justify-center font-extrabold text-lg text-white">BUY GOLDEN SKIN</span>
        </button>

        <button onclick="startGame()" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-8 rounded-lg transition duration-150">Restart Game</button>
        <button onclick="goToScreen('menu')" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-8 rounded-lg transition duration-150">‚Üê Quit</button>
      </div>

      <div id="game-over-modal" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden">
        <div class="bg-red-800 p-8 rounded-xl shadow-2xl text-center border-4 border-red-500">
          <h3 class="text-5xl font-extrabold mb-4 text-white">GAME OVER!</h3>
          <p class="text-2xl mb-6">Your Score: <span id="final-score" class="font-bold">0</span></p>
          <button onclick="startGame()" class="main-button bg-[#e94560] text-2xl font-bold py-3 px-6 rounded-lg hover:bg-[#d53e54] transition duration-150">Try Again!</button>
        </div>
      </div>

      <!-- CURSE MODAL -->
      <div id="curse-modal" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-[#0f172a] p-6 md:p-8 rounded-xl shadow-2xl border-4 border-[#e94560] max-w-3xl w-full">
          <h3 class="text-3xl md:text-4xl font-extrabold mb-4 text-white">Choose your curse</h3>
          <p class="text-sm md:text-base text-gray-300 mb-6">Every 100 levels, you must choose one curse. Some last for a duration, some are permanent.</p>
          <div id="curse-options" class="grid md:grid-cols-3 gap-4"></div>
          <div class="mt-6 flex justify-end">
            <button id="skip-curse-button" class="bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg opacity-50 cursor-not-allowed" disabled>Skip (disabled)</button>
          </div>
        </div>
      </div>
    </div>

    <!-- SHOP SCREEN -->
    <div id="shop-screen" class="screen flex flex-col items-center justify-start pt-16 p-4 overflow-y-auto">
      <h2 class="text-5xl font-bold text-[#e94560] mb-8">The Item Shop</h2>
      <p class="text-xl mb-4 text-center max-w-lg">
        üí∞ Your Coins: <span id="shop-coin-count" class="font-bold text-yellow-400">0</span>
        | High Score: <span id="shop-high-score" class="font-bold text-yellow-400">0</span>
      </p>
      <p class="text-lg mb-8 text-center max-w-lg">Spend your hard-earned coins on upgrades and skins.</p>

      <div class="w-full max-w-2xl space-y-6">
        <!-- Time Ability -->
        <div class="shop-card p-6 border-2 border-[#1c305c]">
          <h3 class="text-3xl font-bold mb-4 text-blue-400">Time Warp Ability (Active)</h3>
          <div class="bg-[#203463] p-4 rounded-lg">
            <p class="text-2xl font-bold">Temporal Slowdown (T)</p>
            <p class="text-lg text-gray-300 mb-2">Temporarily slows the entire game.</p>
            <p class="text-lg">Level: <span id="time-level" class="font-bold text-green-400">0</span></p>
            <p class="text-sm mt-1" id="time-effect">Effect: Not yet purchased.</p>
            <p class="text-sm mt-2 font-semibold text-red-300" id="time-req"></p>
          </div>
          <div class="flex justify-between items-center mt-4">
            <p id="time-cost" class="text-xl font-bold text-yellow-400">Cost: -- Coins</p>
            <button id="buy-time-button" onclick="buyUpgrade('time')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full disabled:bg-gray-500 disabled:cursor-not-allowed">Buy</button>
          </div>
        </div>

        <!-- Hacker Ability -->
        <div class="shop-card p-6 border-2 border-[#1c305c]">
          <h3 class="text-3xl font-bold mb-4 text-purple-400">Hacker Ability (Active)</h3>
          <div class="bg-[#203463] p-4 rounded-lg">
            <p class="text-2xl font-bold">Obstacle Bypass (X)</p>
            <p class="text-lg text-gray-300 mb-2">Bypass obstacles instantly.</p>
            <p class="text-lg">Level: <span id="hacker-level" class="font-bold text-green-400">0</span></p>
            <p class="text-sm mt-1" id="hacker-effect">Effect: Not yet purchased.</p>
            <p class="text-sm mt-2 font-semibold text-red-300" id="hacker-req"></p>
          </div>
          <div class="flex justify-between items-center mt-4">
            <p id="hacker-cost" class="text-xl font-bold text-yellow-400">Cost: -- Coins</p>
            <button id="buy-hacker-button" onclick="buyUpgrade('hacker')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full disabled:bg-gray-500 disabled:cursor-not-allowed">Buy</button>
          </div>
        </div>

        <!-- Jump Upgrade -->
        <div class="shop-card p-6 border-2 border-[#1c305c]">
          <h3 class="text-3xl font-bold mb-4 text-green-400">Jump Upgrade (Passive)</h3>
          <div class="bg-[#203463] p-4 rounded-lg">
            <p class="text-2xl font-bold">Multi-Jump Capability</p>
            <p class="text-lg text-gray-300 mb-2">Jump additional times mid-air before landing.</p>
            <p class="text-lg">Level: <span id="jump-level" class="font-bold text-green-400">0</span></p>
            <p class="text-sm mt-1" id="jump-effect">Effect: Standard single jump.</p>
            <p class="text-sm mt-2 font-semibold text-red-300" id="jump-req"></p>
          </div>
          <div class="flex justify-between items-center mt-4">
            <p id="jump-cost" class="text-xl font-bold text-yellow-400">Cost: -- Coins</p>
            <button id="buy-jump-button" onclick="buyUpgrade('jump')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full disabled:bg-gray-500 disabled:cursor-not-allowed">Buy</button>
          </div>
        </div>

        <!-- Money Magnet -->
        <div class="shop-card p-6 border-2 border-[#1c305c]">
          <h3 class="text-3xl font-bold mb-4 text-yellow-400">Money Magnet (Passive)</h3>
          <div class="bg-[#203463] p-4 rounded-lg">
            <p class="text-2xl font-bold">Coin Attraction Field</p>
            <p class="text-lg text-gray-300 mb-2">Attracts coins towards you and increases their value.</p>
            <p class="text-lg">Level: <span id="magnet-level" class="font-bold text-green-400">0</span></p>
            <p class="text-sm mt-1" id="magnet-effect">Effect: No magnet. Collect coins normally (1 coin value).</p>
            <p class="text-sm mt-2 font-semibold text-red-300" id="magnet-req"></p>
          </div>
          <div class="flex justify-between items-center mt-4">
            <p id="magnet-cost" class="text-xl font-bold text-yellow-400">Cost: -- Coins</p>
            <button id="buy-magnet-button" onclick="buyUpgrade('magnet')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full disabled:bg-gray-500 disabled:cursor-not-allowed">Buy</button>
          </div>
        </div>

        <!-- Skins -->
        <div class="shop-card p-6 border-2 border-[#1c305c]">
          <h3 class="text-3xl font-bold mb-4 text-red-400">Skins</h3>
          <div id="skins-list" class="space-y-4"></div>
        </div>
      </div>

      <button onclick="goToScreen('menu')" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-150 mt-8 mb-4">‚Üê Back to Menu</button>
    </div>

    <!-- LEADERBOARD SCREEN -->
    <div id="leaderboard-screen" class="screen flex flex-col items-center justify-start pt-16 p-4 overflow-y-auto">
      <h2 class="text-5xl font-bold text-[#e94560] mb-8">Leaderboard</h2>
      <p class="text-lg mb-6 text-center max-w-lg">Most levels reached (best score milestones) across all users.</p>
      <table class="w-full max-w-2xl text-left border-collapse">
        <thead class="table-header">
          <tr>
            <th class="p-3">Rank</th>
            <th class="p-3">Player</th>
            <th class="p-3">Best Level</th>
          </tr>
        </thead>
        <tbody id="leaderboard-body" class="text-white"></tbody>
      </table>
      <button onclick="goToScreen('menu')" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg mt-8">‚Üê Back to Menu</button>
    </div>
  </div>

  <script>
    // =======================================================
    // ACCOUNT SYSTEM
    // =======================================================
    let currentUser = null;
    const currentUsernameElement = document.getElementById('current-username');

    function getUserData(username) {
      const data = localStorage.getItem(`stickmanUser_${username}`);
      return data ? JSON.parse(data) : null;
    }
    function saveUserData(username, data) {
      localStorage.setItem(`stickmanUser_${username}`, JSON.stringify(data));
    }
    function togglePassword(fieldId) {
      const passwordField = document.getElementById(fieldId);
      const toggleButton = passwordField.nextElementSibling;
      if (passwordField.type === "password") {
        passwordField.type = "text"; toggleButton.textContent = "Hide";
      } else {
        passwordField.type = "password"; toggleButton.textContent = "Show";
      }
    }
    function createAccount() {
      const username = document.getElementById('username-input').value.trim();
      const password = document.getElementById('password-input').value.trim();
      const confirmPassword = document.getElementById('confirm-password-input').value.trim();
      if (!username || !password || !confirmPassword) { alert("Please fill in all fields."); return; }
      if (password !== confirmPassword) { alert("Passwords do not match."); return; }
      if (getUserData(username)) { alert("Account already exists. Please login."); return; }
      const newUser = {
        password,
        coins: 0,
        highScore: 0,
        bestLevel: 0,
        upgrades: { time:0, hacker:0, jump:0, magnet:0 },
        skins: { owned:['default'], equipped:'default' },
        goldenHackerUnlocked: false
      };
      saveUserData(username, newUser);
      alert("Account created! Please login.");
    }
    function loginAccount() {
      const username = document.getElementById('username-input').value.trim();
      const password = document.getElementById('password-input').value.trim();
      const userData = getUserData(username);
      if (!userData) { alert("No account found. Please create one."); return; }
      if (userData.password !== password) { alert("Incorrect password."); return; }
      currentUser = username;
      loadUserData(userData);
      updateUserStatus();
      goToScreen('menu');
    }
    function logoutAccount() {
      if (!currentUser) { alert("No user is currently logged in."); return; }
      persistUserData();
      alert(`Logged out from ${currentUser}.`);
      currentUser = null;

      // Reset in-memory state
      playerCoins = 0;
      highScore = 0;
      bestLevel = 0;
      timeLevel = 0;
      hackerLevel = 0;
      jumpLevel = 0;
      magnetLevel = 0;
      ownedSkins = { default: true, santa:false, ninja:false, robot:false, pirate:false, alien:false, golden:false };
      equippedSkin = 'default';
      goldenHackerUnlocked = false;

      highScoreElement.textContent = highScore;
      coinCountElement.textContent = playerCoins;
      updateUserStatus();
      goToScreen('login');
    }
    function loadUserData(userData) {
      playerCoins = userData.coins;
      highScore = userData.highScore || 0;
      bestLevel = userData.bestLevel || 0;
      timeLevel = userData.upgrades.time;
      hackerLevel = userData.upgrades.hacker;
      jumpLevel = userData.upgrades.jump;
      magnetLevel = userData.upgrades.magnet;

      // Skins
      ownedSkins = { default: true, santa:false, ninja:false, robot:false, pirate:false, alien:false, golden:false };
      (userData.skins?.owned || []).forEach(id => { ownedSkins[id] = true; });
      equippedSkin = userData.skins?.equipped || 'default';
      goldenHackerUnlocked = !!userData.goldenHackerUnlocked || ownedSkins.golden;

      highScoreElement.textContent = highScore;
      coinCountElement.textContent = playerCoins;
    }
    function persistUserData() {
      if (!currentUser) return;
      const existing = getUserData(currentUser);
      const ownedList = Object.keys(ownedSkins).filter(k => ownedSkins[k]);
      const userData = {
        password: existing?.password || '',
        coins: playerCoins,
        highScore: highScore,
        bestLevel: Math.max(existing?.bestLevel || 0, bestLevel),
        upgrades: { time: timeLevel, hacker: hackerLevel, jump: jumpLevel, magnet: magnetLevel },
        skins: { owned: ownedList, equipped: equippedSkin },
        goldenHackerUnlocked
      };
      saveUserData(currentUser, userData);
    }
    function updateUserStatus() {
      currentUsernameElement.textContent = currentUser ? currentUser : "Guest";
    }

    // =======================================================
    // LEADERBOARD
    // =======================================================
    function getLeaderboard() {
      const leaderboard = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('stickmanUser_')) {
          const data = JSON.parse(localStorage.getItem(key)) || {};
          leaderboard.push({
            username: key.replace('stickmanUser_', ''),
            bestLevel: data.bestLevel || 0
          });
        }
      }
      leaderboard.sort((a, b) => b.bestLevel - a.bestLevel);
      return leaderboard.slice(0, 10);
    }
    function updateLeaderboardUI() {
      const tbody = document.getElementById('leaderboard-body');
      tbody.innerHTML = '';
      const lb = getLeaderboard();
      lb.forEach((entry, index) => {
        const tr = document.createElement('tr');
        tr.className = 'table-row';
        tr.innerHTML = `
          <td class="p-3">${index+1}</td>
          <td class="p-3">${entry.username}</td>
          <td class="p-3">${entry.bestLevel}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    // =======================================================
    // NAVIGATION
    // =======================================================
    let currentScreen = 'login';
    let animationFrameId = null;
    let lastTime = 0;

    const screens = {
      login: document.getElementById('login-screen'),
      menu: document.getElementById('menu-screen'),
      game: document.getElementById('game-screen'),
      shop: document.getElementById('shop-screen'),
      leaderboard: document.getElementById('leaderboard-screen')
    };
    const gameOverModal = document.getElementById('game-over-modal');
    const curseModal = document.getElementById('curse-modal');
    const curseOptionsContainer = document.getElementById('curse-options');

    function goToScreen(targetScreen) {
      if ((targetScreen === 'game' || targetScreen === 'shop' || targetScreen === 'leaderboard') && !currentUser) {
        alert("You must log in first!");
        targetScreen = 'login';
      }
      if (currentScreen === targetScreen) {
        if (targetScreen === 'leaderboard') updateLeaderboardUI();
        return;
      }

      if (currentScreen === 'game') stopGame();

      Object.values(screens).forEach(screen => { if (screen) screen.style.display = 'none'; });
      if (screens[targetScreen]) {
        screens[targetScreen].style.display = 'flex';
        currentScreen = targetScreen;

        if (targetScreen === 'game') {
          resizeCanvas();
          startGame();
        } else if (targetScreen === 'shop') {
          updateShopUI();
          updateSkinsUI();
        } else if (targetScreen === 'leaderboard') {
          updateLeaderboardUI();
        }
      } else {
        console.error(`Unknown screen: ${targetScreen}`);
      }
    }

    window.onload = () => {
      goToScreen('login');
      updateUserStatus();
    };
    window.addEventListener('resize', () => {
      if (currentScreen === 'game') resizeCanvas();
    });

    // =======================================================
    // GAME CONSTANTS AND STATE
    // =======================================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Gravity: start at 0.4 and increase slowly
    const BASE_GRAVITY_START = 0.4;
    const MAX_GRAVITY = 1.0; // lower cap to keep late-game less punishing
    const GRAVITY_SLOW_FACTOR = 1.5; // increases more slowly

    const JUMP_VELOCITY = -12;

    // Speed scaling (ramps to max by 250 UI score)
    const BASE_GAME_SPEED = 4.0;
    const MAX_GAME_SPEED_INCREASE = 8.0;
    const MAX_SCORE_FOR_SPEED = 250;

    const MAX_SCORE_FOR_OBSTACLE_DENSITY = 300;
    let obstacleSpawnRate = 100;
    const MIN_OBSTACLE_RATE = 20;

    const GROUND_HEIGHT = 50;
    const PLAYER_SIZE = 40;

    let player;
    let obstacles = [];
    let coins = [];
    let holes = [];
    let traps = [];
    let score = 0;                 // internal score ticker
    let currentSpeed = BASE_GAME_SPEED;

    let highScore = 0;
    let bestLevel = 0;
    let playerCoins = 0;

    let timeLevel = 0;
    let hackerLevel = 0;
    let jumpLevel = 0;
    let magnetLevel = 0;

    let jumpCount = 0;
    let isFalling = false;

    let isHackerAbilityReady = true;
    let hackerCooldownRemaining = 0;

    let isTimeAbilityReady = true;
    let timeCooldownRemaining = 0;
    let timeEffectRemaining = 0;

    let isGameOver = false;
    let isPausedForCurse = false;
    let lastCurseThresholdAwarded = 0;

    let obstacleSpawnTimer = 0;
    let coinSpawnTimer = 0;
    const COIN_SPAWN_RATE = 350;

    // Skins
    const SKINS = [
      { id: 'santa',  name: 'Santa Skin',  cost: 5 },
      { id: 'ninja',  name: 'Ninja Skin',  cost: 10 },
      { id: 'robot',  name: 'Robot Skin',  cost: 15 },
      { id: 'pirate', name: 'Pirate Skin', cost: 20 },
      { id: 'alien',  name: 'Alien Skin',  cost: 25 },
      { id: 'golden', name: 'Golden Skin', cost: 100 }
    ];
    let ownedSkins = { default: true, santa:false, ninja:false, robot:false, pirate:false, alien:false, golden:false };
    let equippedSkin = 'default';

    // Golden Hacker special upgrade unlocked with golden skin
    const GOLDEN_HACKER_UPGRADE = { cooldown: 10000 };
    let goldenHackerUnlocked = false;
    let goldenHackerCooldownRemaining = 0;
    let goldenHackerReady = true;

    // Trap rarity and threshold
    const TRAP_SPAWN_PROBABILITY = 0.015; // rare spawn
    const TRAP_MIN_UI_SCORE = 250;        // begin spawning traps at 250 UI score

    // Magnet settings ‚Äî zip mode uses radius from upgrade
    const magnetForce = 0.025; // retained (not used directly in zip mode)

    // =======================================================
    // UPGRADES SETUP (UPDATED REQUIREMENTS)
    // =======================================================
    const TIME_UPGRADE = {
      costs: [12, 20, 35],
      cooldowns: [30000, 20000, 35000],
      highScoreRequirement: [200, 300, 0],
      effectDuration: [4000, 5000, 6000],
      slowdownFactor: [0.7, 0.5, 'BASE'],
      maxLevel: 3,
      effect: (level) => {
        if (level === 0) return 'Not yet purchased.';
        const cd = TIME_UPGRADE.cooldowns[level - 1] / 1000;
        if (level === 3) return `Cooldown: ${cd}s. Resets speed to base for ${TIME_UPGRADE.effectDuration[level-1]/1000}s.`;
        const factor = TIME_UPGRADE.slowdownFactor[level-1];
        return `Cooldown: ${cd}s. Slows speed to ${Math.floor(factor * 100)}% for ${TIME_UPGRADE.effectDuration[level-1]/1000}s.`;
      }
    };

    const HACKER_UPGRADE = {
      costs: [10, 25, 40],
      cooldowns: [9000, 13000, 16000],
      highScoreRequirement: [200, 550, 800],
      maxLevel: 3,
      effect: (level) => {
        if (level === 0) return 'Not yet purchased.';
        if (level === 1) return 'Cooldown: 9s. Bypasses 1 obstacle.';
        if (level === 2) return 'Cooldown: 13s. Bypasses 2 obstacles.';
        if (level === 3) return 'Cooldown: 16s. Bypasses 3 obstacles & holes.';
      }
    };

    const JUMP_UPGRADE = {
      costs: [20, 60],
      highScoreRequirement: [400, 650],
      maxLevels: [2, 3],
      maxLevel: 2,
      effect: (level) => {
        if (level === 0) return 'Standard single jump.';
        if (level === 1) return `Double Jump (${JUMP_UPGRADE.maxLevels[0]} jumps).`;
        if (level === 2) return `Triple Jump (${JUMP_UPGRADE.maxLevels[1]} jumps).`;
      }
    };

    const MAGNET_UPGRADE = {
      costs: [40, 80],
      highScoreRequirement: [300, 800],
      values: [2, 3],         // 2x, 3x coin value multipliers
      radii: [150, 300],      // attraction radius by level
      maxLevel: 2,
      effect: (level) => {
        if (level === 0) return 'No magnet. Coins worth 1.';
        if (level === 1) return 'Magnet active. Coins worth 2x.';
        if (level === 2) return 'Strong magnet. Coins worth 3x.';
      }
    };
    const UPGRADES = { time: TIME_UPGRADE, hacker: HACKER_UPGRADE, jump: JUMP_UPGRADE, magnet: MAGNET_UPGRADE };

    // =======================================================
    // CURSE SYSTEM
    // =======================================================
    // Ratings: not so bad, bad, horrible, very horrible
    const CURSE_RATING_CLASS = {
      'Not so bad': 'badge badge-not',
      'Bad': 'badge badge-bad',
      'Horrible': 'badge badge-horrible',
      'Very Horrible': 'badge badge-very'
    };

    // Active curse state
    let activeCurses = []; // [{id, name, rating, expiresAt(null if permanent)}]
    let curseTimers = {};  // id -> remaining ms for timed curses

    // Effects toggles
    let curseFogActive = false;
    let curseCoinTaxActive = false;
    let curseSlipperyActive = false;
    let curseDoubleGravityActive = false;
    let curseSlowRecoverActive = false;
    let curseMagnetMalfunctionActive = false;
    let curseObstacleFrenzyActive = false;
    let curseTrapStormActive = false;
    let curseBlindBarActive = false;
    let cursePermanentGravityBoost = 0;  // accumulates
    let curseCoinDrainActive = false;
    let curseSpeedSurgeActive = false;

    // Blind bar settings
    const blindBar = { x: 0, w: 80, h: 9999 };

    // Coin drain timer
    let coinDrainTimer = 0;

    // Curse pool
    const CURSES = [
      // Not so bad
      { id: 'fog', name: 'Foggy Vision', rating: 'Not so bad', duration: 30000,
        description: 'A soft fog reduces visibility for 30s.',
        apply: () => { curseFogActive = true; },
        cleanup: () => { curseFogActive = false; }
      },
      { id: 'coinTax', name: 'Coin Tax', rating: 'Not so bad', duration: 20000,
        description: 'Coins grant half value for 20s.',
        apply: () => { curseCoinTaxActive = true; },
        cleanup: () => { curseCoinTaxActive = false; }
      },
      { id: 'slippery', name: 'Slippery Feet', rating: 'Not so bad', duration: 20000,
        description: 'Landing slides you slightly for 20s.',
        apply: () => { curseSlipperyActive = true; },
        cleanup: () => { curseSlipperyActive = false; }
      },

      // Bad
      { id: 'doubleGravity', name: 'Double Gravity', rating: 'Bad', duration: 15000,
        description: 'Gravity doubles for 15s.',
        apply: () => { curseDoubleGravityActive = true; },
        cleanup: () => { curseDoubleGravityActive = false; }
      },
      { id: 'slowRecover', name: 'Slow Recovery', rating: 'Bad', duration: 20000,
        description: 'Crouch recovery becomes sluggish for 20s.',
        apply: () => { curseSlowRecoverActive = true; },
        cleanup: () => { curseSlowRecoverActive = false; }
      },
      { id: 'magnetMalfunction', name: 'Magnet Malfunction', rating: 'Bad', duration: 20000,
        description: 'Magnet repels coins for 20s.',
        apply: () => { curseMagnetMalfunctionActive = true; },
        cleanup: () => { curseMagnetMalfunctionActive = false; }
      },

      // Horrible
      { id: 'obstacleFrenzy', name: 'Obstacle Frenzy', rating: 'Horrible', duration: 30000,
        description: 'Obstacle spawn rate doubles for 30s.',
        apply: () => { curseObstacleFrenzyActive = true; },
        cleanup: () => { curseObstacleFrenzyActive = false; }
      },
      { id: 'trapStorm', name: 'Trap Storm', rating: 'Horrible', duration: 25000,
        description: 'Traps spawn much more frequently for 25s.',
        apply: () => { curseTrapStormActive = true; },
        cleanup: () => { curseTrapStormActive = false; }
      },
      { id: 'blindBar', name: 'Blind Spot', rating: 'Horrible', duration: 25000,
        description: 'A black bar blocks part of your view for 25s.',
        apply: () => { curseBlindBarActive = true; blindBar.x = Math.random() * 200 + 80; blindBar.w = 80 + Math.random()*80; },
        cleanup: () => { curseBlindBarActive = false; }
      },

      // Very Horrible (permanent)
      { id: 'permGravity', name: 'Permanent Gravity Boost', rating: 'Very Horrible', duration: null,
        description: 'Gravity permanently increases by +0.3.',
        apply: () => { cursePermanentGravityBoost += 0.3; },
        cleanup: () => {}
      },
      { id: 'coinDrain', name: 'Coin Drain', rating: 'Very Horrible', duration: null,
        description: 'Lose 1 coin every 5 seconds until game over.',
        apply: () => { curseCoinDrainActive = true; coinDrainTimer = 0; },
        cleanup: () => {}
      },
      { id: 'speedSurge', name: 'Speed Surge', rating: 'Very Horrible', duration: null,
        description: 'Base speed permanently increases by +2.',
        apply: () => { curseSpeedSurgeActive = true; },
        cleanup: () => {}
      }
    ];

    function pickRandomCurses(count = 3) {
      const pool = [...CURSES];
      const picks = [];
      for (let i = 0; i < count && pool.length > 0; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        picks.push(pool[idx]);
        pool.splice(idx, 1);
      }
      return picks;
    }

    function showCurseChoice() {
      isPausedForCurse = true;
      curseModal.style.display = 'flex';
      curseOptionsContainer.innerHTML = '';
      const options = pickRandomCurses(3);
      options.forEach(curse => {
        const card = document.createElement('div');
        card.className = 'bg-[#1b2c4a] p-4 rounded-lg border-2 border-[#1c305c] flex flex-col justify-between';
        const badgeClass = CURSE_RATING_CLASS[curse.rating] || 'badge';
        card.innerHTML = `
          <div>
            <div class="flex items-center justify-between">
              <h4 class="text-xl font-bold text-white">${curse.name}</h4>
              <span class="${badgeClass}">${curse.rating}</span>
            </div>
            <p class="text-sm text-gray-300 mt-2">${curse.description}</p>
            <p class="text-xs text-gray-400 mt-1">${curse.duration ? `Duration: ${Math.floor(curse.duration/1000)}s` : 'Permanent'}</p>
          </div>
          <button class="mt-4 bg-[#e94560] hover:bg-[#d53e54] text-white font-bold py-2 px-4 rounded-lg">Choose</button>
        `;
        const btn = card.querySelector('button');
        btn.addEventListener('click', () => applyCurseAndResume(curse));
        curseOptionsContainer.appendChild(card);
      });
    }

    function applyCurseAndResume(curse) {
      curse.apply();
      const now = performance.now();
      activeCurses.push({
        id: curse.id, name: curse.name, rating: curse.rating,
        expiresAt: curse.duration ? now + curse.duration : null
      });
      if (curse.duration) curseTimers[curse.id] = curse.duration;

      // Update permanent values immediately
      if (curse.id === 'speedSurge') {
        // Increase base speed; keep max speed increase same so curve shifts up modestly
        // We won't mutate constants; instead apply an offset in speed calc
        // Marked via curseSpeedSurgeActive flag
      }

      resumeAfterCurse();
    }

    function resumeAfterCurse() {
      curseModal.style.display = 'none';
      isPausedForCurse = false;
      lastCurseThresholdAwarded = Math.floor((score/10) / 100) * 100; // record the 100s threshold
      // Re-launch loop if it was stopped
      if (!animationFrameId && currentScreen === 'game' && !isGameOver) {
        lastTime = 0;
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function updateCurses(deltaTime) {
      if (activeCurses.length === 0) return;
      const now = performance.now();
      for (let i = activeCurses.length - 1; i >= 0; i--) {
        const c = activeCurses[i];
        if (c.expiresAt && now >= c.expiresAt) {
          // cleanup and remove
          const curseDef = CURSES.find(x => x.id === c.id);
          if (curseDef && curseDef.cleanup) curseDef.cleanup();
          delete curseTimers[c.id];
          activeCurses.splice(i, 1);
        } else if (c.expiresAt) {
          // decrement timer
          curseTimers[c.id] = Math.max(0, curseTimers[c.id] - deltaTime);
        }
      }

      // Coin drain ticking
      if (curseCoinDrainActive) {
        coinDrainTimer += deltaTime;
        if (coinDrainTimer >= 5000) {
          coinDrainTimer = 0;
          if (playerCoins > 0) {
            playerCoins -= 1;
            coinCountElement.textContent = playerCoins;
            persistUserData();
          }
        }
      }
    }

    // =======================================================
    // UI ELEMENTS
    // =======================================================
    const scoreElement = document.getElementById('current-score');
    const highScoreElement = document.getElementById('high-score');
    const finalScoreElement = document.getElementById('final-score');
    const coinCountElement = document.getElementById('coin-count');
    const shopCoinCountElement = document.getElementById('shop-coin-count');
    const shopHighScoreElement = document.getElementById('shop-high-score');

    const hackerButton = document.getElementById('hacker-button');
    const hackerCooldownOverlay = document.getElementById('hacker-cooldown-overlay');
    const hackerCooldownText = document.getElementById('hacker-cooldown-text');

    const timeButton = document.getElementById('time-button');
    const timeCooldownOverlay = document.getElementById('time-cooldown-overlay');
    const timeCooldownText = document.getElementById('time-cooldown-text');

    const goldenHackerButton = document.getElementById('golden-hacker-button');
    const goldenHackerCooldownOverlay = document.getElementById('golden-hacker-cooldown-overlay');
    const goldenHackerCooldownText = document.getElementById('golden-hacker-cooldown-text');

    // =======================================================
    // UTILS: DYNAMIC GRAVITY
    // =======================================================
    function getDynamicGravity(multiplier = 1) {
      const maxSpeed = BASE_GAME_SPEED + MAX_GAME_SPEED_INCREASE;
      let baseSpeedAdj = BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0);
      // Slow growth factor
      const speedFactor = Math.min((currentSpeed - baseSpeedAdj) / ((maxSpeed - baseSpeedAdj) * GRAVITY_SLOW_FACTOR), 1);
      const gravityBase = BASE_GRAVITY_START + cursePermanentGravityBoost;
      let gravity = gravityBase + (MAX_GRAVITY - gravityBase) * Math.max(0, speedFactor);
      if (curseDoubleGravityActive) gravity *= 2;
      return gravity * multiplier;
    }

    // =======================================================
    // CLASSES
    // =======================================================
    class Player {
      constructor() {
        this.width = PLAYER_SIZE / 2;
        this.height = PLAYER_SIZE;
        this.x = 50;
        this.y = canvas.height - GROUND_HEIGHT - this.height;
        this.velocityY = 0;
        this.isCrouching = false;
        this.skin = equippedSkin;
        this.slideVelocityX = 0; // for slippery curse
      }
      setSkin(skinName) { this.skin = skinName; }
      crouch(on) {
        this.isCrouching = on;
        const targetHeight = on ? PLAYER_SIZE / 2 : PLAYER_SIZE;
        if (curseSlowRecoverActive && !on) {
          // delay recovery
          setTimeout(() => {
            this.height = targetHeight;
            this.y = canvas.height - GROUND_HEIGHT - this.height;
          }, 250);
        } else {
          this.height = targetHeight;
          this.y = canvas.height - GROUND_HEIGHT - this.height;
        }
      }
      jump() {
        if (!isGameOver && !isFalling && !this.isCrouching) {
          let maxJumps = 1;
          if (jumpLevel === 1) maxJumps = JUMP_UPGRADE.maxLevels[0];
          if (jumpLevel === 2) maxJumps = JUMP_UPGRADE.maxLevels[1];
          if (jumpCount < maxJumps) {
            this.velocityY = JUMP_VELOCITY;
            jumpCount++;
          }
        }
      }
      draw() {
        // Skin visuals
        switch (this.skin) {
          case 'santa':
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(this.x, this.y, this.width, 5);
            ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y - 10, 6, 0, Math.PI*2);
            ctx.fillStyle = '#ffffff'; ctx.fill();
            break;
          case 'ninja':
            ctx.fillStyle = '#0b0b0b';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#444'; ctx.fillRect(this.x, this.y, this.width, 4);
            break;
          case 'robot':
            ctx.fillStyle = '#8a8a8a';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#00e1ff'; ctx.fillRect(this.x + this.width/4, this.y + 4, this.width/2, 4);
            break;
          case 'pirate':
            ctx.fillStyle = '#7b3f00';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#222'; ctx.fillRect(this.x, this.y, this.width, 5);
            ctx.fillStyle = '#000'; ctx.fillRect(this.x + this.width - 6, this.y + 4, 6, 6);
            break;
          case 'alien':
            ctx.fillStyle = '#2bdc73';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#a6ffb5'; ctx.fillRect(this.x + this.width/4, this.y, this.width/2, 3);
            break;
          case 'golden':
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#fff2a8'; ctx.fillRect(this.x, this.y, this.width, 4);
            break;
          default:
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + 5, 5, 0, Math.PI * 2); ctx.stroke();
            const bodyTop = this.y + 10;
            const bodyBottom = this.isCrouching ? this.y + 20 : this.y + 25;
            ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, bodyTop); ctx.lineTo(this.x + this.width / 2, bodyBottom); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x, this.y + (this.isCrouching ? 20 : 15)); ctx.lineTo(this.x + this.width, this.y + (this.isCrouching ? 20 : 15)); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.x + this.width / 2, bodyBottom); ctx.lineTo(this.x, this.y + this.height);
            ctx.moveTo(this.x + this.width / 2, bodyBottom); ctx.lineTo(this.x + this.width, this.y + this.height);
            ctx.stroke();
        }
      }
    }

    class Coin {
      constructor() {
        this.size = 15;
        this.x = canvas.width;
        this.color = '#FFD700';
        this.baseValue = 1;

        const level = Math.floor(Math.random() * 3);
        if (level === 0) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 3.5;
        else if (level === 1) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 1.5;
        else this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 0.5;
      }
      update() { this.x -= currentSpeed; }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Obstacle {
      constructor(type) {
        this.type = type;
        this.width = 20 + Math.random() * 20;
        this.defaultColor = type === 'ground' ? '#ff6b6b' : '#647DEE';
        this.color = this.defaultColor;
        this.isBypassed = false;
        if (type === 'ground') {
          this.height = 20 + Math.random() * 30;
          this.x = canvas.width;
          this.y = canvas.height - GROUND_HEIGHT - this.height;
        } else {
          this.height = 15;
          this.width = 40 + Math.random() * 30;
          this.x = canvas.width;
          this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 2.5 - Math.random() * 50;
          this.vy = 0.3; // swoop speed (air obstacles descend after late game)
        }
      }
      update() {
        this.x -= currentSpeed;
        if (this.type === 'air' && Math.floor(score / 10) >= 250) {
          this.y += this.vy;
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        if (this.type === 'ground' && this.color === this.defaultColor) {
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(this.x, canvas.height - GROUND_HEIGHT, this.width, 10);
        }
      }
    }

    class Hole {
      constructor() {
        const baseWidth = 75;
        const randomExtra = Math.random() * 75;
        const uiScore = Math.floor(score / 10);
        const scaling = Math.min(uiScore / 200, 3);
        this.width = (baseWidth + randomExtra) * (1 + scaling * 0.3);
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT;
        this.height = GROUND_HEIGHT;
        this.isHazard = true;
        this.isBypassed = false;
        this.color = '#16213e';
      }
      update() { this.x -= currentSpeed; }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeStyle = '#0f172a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.width, this.y);
        ctx.stroke();
      }
    }

    class Trap {
      constructor() {
        this.width = 75 + Math.random() * 75;
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT;
        this.height = GROUND_HEIGHT;
        this.isTriggered = false;
        this.color = '#2d3748';
        this.tintAlpha = 0.08;
        this.animationProgress = 0;
      }
      update() {
        this.x -= currentSpeed;
        if (this.isTriggered && this.animationProgress < 1) {
          this.animationProgress += 0.06;
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        if (!this.isTriggered) {
          ctx.fillStyle = `rgba(255,0,0,${this.tintAlpha})`;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        const stickHeight = 20;
        const stickWidth = 6;
        const spacing = 20;
        const numSticks = Math.floor(this.width / spacing);
        const topRowY = this.y;
        const bottomRowY = this.y;
        for (let i = 0; i < numSticks; i++) {
          const baseX = this.x + i * spacing + 5;
          ctx.save();
          ctx.translate(baseX, topRowY);
          if (this.isTriggered) ctx.rotate(-Math.PI / 4 * this.animationProgress);
          ctx.fillStyle = '#2b2f3a';
          ctx.fillRect(-stickWidth/2, -stickHeight, stickWidth, stickHeight);
          ctx.restore();
          ctx.save();
          ctx.translate(baseX + spacing/2, bottomRowY);
          if (this.isTriggered) ctx.rotate(Math.PI / 4 * this.animationProgress);
          ctx.fillStyle = '#2b2f3a';
          ctx.fillRect(-stickWidth/2, -stickHeight, stickWidth, stickHeight);
          ctx.restore();
        }
      }
    }

    // =======================================================
    // ABILITIES
    // =======================================================
    function activateHackerAbility() {
      if (hackerLevel === 0 || !isHackerAbilityReady || isGameOver || isPausedForCurse) return;
      isHackerAbilityReady = false;
      const currentCooldown = HACKER_UPGRADE.cooldowns[hackerLevel - 1];
      hackerCooldownRemaining = currentCooldown;

      let bypassCount = 1;
      if (hackerLevel === 2) bypassCount = 2;
      if (hackerLevel === 3) bypassCount = 3;

      let targets = obstacles.filter(obs => obs.x > player.x && !obs.isBypassed);
      if (hackerLevel === 3) {
        const holeTargets = holes.filter(h => !h.isBypassed && h.x > player.x);
        targets = targets.concat(holeTargets);
      }

      for (let i = 0; i < bypassCount && i < targets.length; i++) {
        const target = targets[i];
        if (target instanceof Obstacle) {
          target.isBypassed = true;
          target.color = '#059669';
        } else if (target instanceof Hole) {
          target.isBypassed = true;
          target.color = '#34d399';
        }
      }
      updateHackerButtonUI();
    }

    function activateTimeAbility() {
      if (timeLevel === 0 || !isTimeAbilityReady || isGameOver || isPausedForCurse) return;
      isTimeAbilityReady = false;
      const currentCooldown = TIME_UPGRADE.cooldowns[timeLevel - 1];
      timeCooldownRemaining = currentCooldown;
      const factor = TIME_UPGRADE.slowdownFactor[timeLevel - 1];
      currentSpeed = factor === 'BASE' ? BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0) : currentSpeed * factor;
      timeEffectRemaining = TIME_UPGRADE.effectDuration[timeLevel - 1];
      canvas.style.borderColor = '#60a5fa';
      updateTimeButtonUI();
    }

    function activateGoldenHacker() {
      if (!goldenHackerUnlocked || !goldenHackerReady || isGameOver || isPausedForCurse) return;
      goldenHackerReady = false;
      goldenHackerCooldownRemaining = GOLDEN_HACKER_UPGRADE.cooldown;

      const target = obstacles.find(obs => obs.x > player.x && !obs.isBypassed);
      if (target) {
        target.isBypassed = true;
        target.color = '#FFD700';
        playerCoins += 2;
        coinCountElement.textContent = playerCoins;
        persistUserData();
      }
      updateGoldenHackerButtonUI();
    }

    function updateHackerButtonUI() {
      if (hackerLevel === 0) {
        hackerButton.disabled = true;
        hackerCooldownText.textContent = 'BUY IN SHOP';
        hackerCooldownOverlay.style.height = '100%';
        return;
      }
      if (isHackerAbilityReady && !isPausedForCurse) {
        hackerButton.disabled = false;
        hackerCooldownText.textContent = 'READY (X)';
        hackerCooldownOverlay.style.height = '0%';
        hackerButton.classList.remove('bg-gray-700');
        hackerButton.classList.add('bg-purple-600', 'hover:bg-purple-700');
      } else {
        hackerButton.disabled = true;
        hackerButton.classList.remove('bg-purple-600', 'hover:bg-purple-700');
        hackerButton.classList.add('bg-gray-700');
        const totalCooldown = HACKER_UPGRADE.cooldowns[hackerLevel - 1];
        const remainingSec = Math.ceil(hackerCooldownRemaining / 1000);
        const percent = (hackerCooldownRemaining / totalCooldown) * 100;
        hackerCooldownText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        hackerCooldownOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }

    function updateTimeButtonUI() {
      if (timeLevel === 0) {
        timeButton.disabled = true;
        timeCooldownText.textContent = 'BUY IN SHOP';
        timeCooldownOverlay.style.height = '100%';
        return;
      }
      if (timeEffectRemaining > 0) {
        timeButton.disabled = true;
        const remainingEffectSec = Math.ceil(timeEffectRemaining / 1000);
        timeCooldownText.textContent = `WARP: ${remainingEffectSec}s`;
        timeCooldownOverlay.style.height = '0%';
        timeButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-gray-700');
        timeButton.classList.add('bg-blue-800');
        return;
      }
      if (isTimeAbilityReady && !isPausedForCurse) {
        timeButton.disabled = false;
        timeCooldownText.textContent = 'READY (T)';
        timeCooldownOverlay.style.height = '0%';
        timeButton.classList.remove('bg-gray-700');
        timeButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
      } else {
        timeButton.disabled = true;
        timeButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
        timeButton.classList.add('bg-gray-700');
        const totalCooldown = TIME_UPGRADE.cooldowns[timeLevel - 1];
        const remainingSec = Math.ceil(timeCooldownRemaining / 1000);
        const percent = (timeCooldownRemaining / totalCooldown) * 100;
        timeCooldownText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        timeCooldownOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }

    function updateGoldenHackerButtonUI() {
      if (!goldenHackerUnlocked) {
        goldenHackerButton.disabled = true;
        goldenHackerCooldownText.textContent = 'BUY GOLDEN SKIN';
        goldenHackerCooldownOverlay.style.height = '100%';
        return;
      }
      if (goldenHackerReady && !isPausedForCurse) {
        goldenHackerButton.disabled = false;
        goldenHackerCooldownText.textContent = 'READY (G)';
        goldenHackerCooldownOverlay.style.height = '0%';
        goldenHackerButton.classList.remove('bg-gray-700');
        goldenHackerButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
      } else {
        goldenHackerButton.disabled = true;
        goldenHackerButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
        goldenHackerButton.classList.add('bg-gray-700');
        const totalCd = GOLDEN_HACKER_UPGRADE.cooldown;
        const remainingSec = Math.ceil(goldenHackerCooldownRemaining / 1000);
        const percent = (goldenHackerCooldownRemaining / totalCd) * 100;
        goldenHackerCooldownText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        goldenHackerCooldownOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }

    // =======================================================
    // INPUT
    // =======================================================
    function handleInput() {
      document.addEventListener('keydown', (e) => {
        if (!isGameOver && !isPausedForCurse) {
          if (e.code === 'Space' || e.code === 'Enter') player.jump();
          if (e.key === 'x' || e.key === 'X') activateHackerAbility();
          if (e.key === 't' || e.key === 'T') activateTimeAbility();
          if (e.key === 'g' || e.key === 'G') activateGoldenHacker();
          if (e.key === 'ArrowDown' || e.key === 's') player.crouch(true);
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowDown' || e.key === 's') player.crouch(false);
      });

      document.getElementById('jump-button').addEventListener('click', () => { if (!isGameOver && !isPausedForCurse) player.jump(); });

      const crouchButton = document.getElementById('crouch-button');
      crouchButton.addEventListener('mousedown', () => !isPausedForCurse && player.crouch(true));
      crouchButton.addEventListener('mouseup', () => player.crouch(false));
      crouchButton.addEventListener('mouseleave', () => player.crouch(false));
      crouchButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isPausedForCurse) player.crouch(true); });
      crouchButton.addEventListener('touchend', (e) => { e.preventDefault(); player.crouch(false); });

      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isGameOver && !isPausedForCurse) player.jump(); });
    }

    // =======================================================
    // SHOP LOGIC
    // =======================================================
    function buyUpgrade(upgradeName) {
      const upgrade = UPGRADES[upgradeName];
      const currentLevel = getUpgradeLevel(upgradeName);
      if (currentLevel < upgrade.maxLevel) {
        const cost = upgrade.costs[currentLevel];
        const requiredScore = upgrade.highScoreRequirement[currentLevel];
        if (highScore < requiredScore) { alert(`High Score of ${requiredScore} required.`); return; }
        if (playerCoins >= cost) {
          playerCoins -= cost;
          const newLevel = currentLevel + 1;
          setUpgradeLevel(upgradeName, newLevel);
          coinCountElement.textContent = playerCoins;
          updateShopUI();
          persistUserData();
          if (upgradeName === 'hacker') updateHackerButtonUI();
          if (upgradeName === 'time') updateTimeButtonUI();
        } else {
          alert('Not enough coins.');
        }
      }
    }
    function getUpgradeLevel(key) {
      if (key === 'time') return timeLevel;
      if (key === 'hacker') return hackerLevel;
      if (key === 'jump') return jumpLevel;
      if (key === 'magnet') return magnetLevel;
      return 0;
    }
    function setUpgradeLevel(key, level) {
      if (key === 'time') timeLevel = level;
      if (key === 'hacker') hackerLevel = level;
      if (key === 'jump') jumpLevel = level;
      if (key === 'magnet') magnetLevel = level;
    }

    // Skins UI (dynamic with previews)
    function updateSkinsUI() {
      const skinsList = document.getElementById('skins-list');
      skinsList.innerHTML = '';
      SKINS.forEach(skin => {
        const owned = ownedSkins[skin.id];
        const equipped = equippedSkin === skin.id;
        const div = document.createElement('div');
        div.className = 'bg-[#203463] p-4 rounded-lg';

        div.innerHTML = `
          <div class="flex items-center gap-4">
            <canvas id="preview-${skin.id}" width="50" height="70" class="skin-preview"></canvas>
            <div>
              <p class="text-2xl font-bold">${skin.name}</p>
              <p class="text-lg text-gray-300">Cost: ${skin.cost} Coins</p>
              <p class="text-lg">Owned: <span class="font-bold ${owned ? 'text-green-400' : 'text-red-400'}">${owned ? 'Yes' : 'No'}</span></p>
              <p class="text-lg">Equipped: <span class="font-bold ${equipped ? 'text-green-400' : 'text-red-400'}">${equipped ? 'Yes' : 'No'}</span></p>
            </div>
          </div>
          <div class="flex gap-2 mt-3">
            <button onclick="buySkin('${skin.id}')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full ${owned ? 'opacity-50 cursor-not-allowed' : ''}" ${owned ? 'disabled' : ''}>Buy</button>
            <button onclick="equipSkin('${skin.id}')" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full ${owned ? '' : 'opacity-50 cursor-not-allowed'}" ${owned ? '' : 'disabled'}>Equip</button>
          </div>
        `;
        skinsList.appendChild(div);
        renderSkinPreview(skin.id);
      });
      updateGoldenHackerButtonUI();
    }

    function renderSkinPreview(skinId) {
      const canvas = document.getElementById(`preview-${skinId}`);
      if (!canvas) return;
      const ctxP = canvas.getContext('2d');
      ctxP.clearRect(0, 0, canvas.width, canvas.height);
      const x = 15, y = 20, w = 20, h = 30;

      switch (skinId) {
        case 'santa':
          ctxP.fillStyle = '#ff0000'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#ffffff'; ctxP.fillRect(x, y, w, 5);
          ctxP.beginPath(); ctxP.arc(x + w/2, y - 8, 6, 0, Math.PI*2); ctxP.fillStyle = '#ffffff'; ctxP.fill();
          break;
        case 'ninja':
          ctxP.fillStyle = '#0b0b0b'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#444'; ctxP.fillRect(x, y, w, 4);
          break;
        case 'robot':
          ctxP.fillStyle = '#8a8a8a'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#00e1ff'; ctxP.fillRect(x + w/4, y + 6, w/2, 4);
          break;
        case 'pirate':
          ctxP.fillStyle = '#7b3f00'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#222'; ctxP.fillRect(x, y, w, 5);
          ctxP.fillStyle = '#000'; ctxP.fillRect(x + w - 6, y + 6, 6, 6);
          break;
        case 'alien':
          ctxP.fillStyle = '#2bdc73'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#a6ffb5'; ctxP.fillRect(x + w/4, y, w/2, 3);
          break;
        case 'golden':
          ctxP.fillStyle = '#FFD700'; ctxP.fillRect(x, y, w, h);
          ctxP.fillStyle = '#fff2a8'; ctxP.fillRect(x, y, w, 4);
          break;
        default:
          ctxP.strokeStyle = '#FFFFFF'; ctxP.strokeRect(x, y, w, h);
      }

      // Head
      ctxP.beginPath(); ctxP.arc(x + w/2, y - 5, 5, 0, Math.PI * 2);
      ctxP.strokeStyle = '#FFFFFF'; ctxP.stroke();
    }

    function buySkin(skinId) {
      const skin = SKINS.find(s => s.id === skinId);
      if (!skin) return;
      if (ownedSkins[skinId]) { alert('Already owned.'); return; }
      if (playerCoins < skin.cost) { alert('Not enough coins.'); return; }
      playerCoins -= skin.cost;
      ownedSkins[skinId] = true;
      coinCountElement.textContent = playerCoins;

      if (skinId === 'golden') {
        goldenHackerUnlocked = true;
        updateGoldenHackerButtonUI();
      }

      updateSkinsUI();
      updateShopUI();
      persistUserData();
    }

    function equipSkin(skinId) {
      if (!ownedSkins[skinId]) { alert('Skin not owned.'); return; }
      equippedSkin = skinId;
      updateSkinsUI();
      if (player) player.setSkin(equippedSkin);
      persistUserData();
    }

    function updateShopUI() {
      shopCoinCountElement.textContent = playerCoins;
      shopHighScoreElement.textContent = highScore;

      Object.keys(UPGRADES).forEach(key => {
        const upgrade = UPGRADES[key];
        const currentLevel = getUpgradeLevel(key);
        const levelElement = document.getElementById(`${key}-level`);
        const effectElement = document.getElementById(`${key}-effect`);
        const costElement = document.getElementById(`${key}-cost`);
        const buyButton = document.getElementById(`buy-${key}-button`);
        const reqElement = document.getElementById(`${key}-req`);
        if (!levelElement || !buyButton) return;

        levelElement.textContent = currentLevel;
        effectElement.textContent = upgrade.effect(currentLevel);

        if (currentLevel < upgrade.maxLevel) {
          const nextLevel = currentLevel + 1;
          const nextCost = upgrade.costs[currentLevel];
          const requiredScore = upgrade.highScoreRequirement[currentLevel];
          costElement.textContent = `Cost: ${nextCost} Coins`;
          buyButton.textContent = `Buy Level ${nextLevel}`;

          let canBuy = true;
          if (requiredScore > 0 && highScore < requiredScore) {
            reqElement.textContent = `Required High Score: ${requiredScore} points.`;
            reqElement.classList.remove('text-green-300'); reqElement.classList.add('text-red-300');
            canBuy = false;
          } else {
            reqElement.textContent = requiredScore > 0 ? `Requirement Met (${requiredScore})` : `No High Score requirement.`;
            reqElement.classList.remove('text-red-300'); reqElement.classList.add('text-green-300');
          }
          if (playerCoins < nextCost || !canBuy) {
            buyButton.disabled = true;
            if (playerCoins < nextCost) buyButton.textContent = 'Not Enough Coins';
            else if (!canBuy) buyButton.textContent = 'Score Too Low';
          } else {
            buyButton.disabled = false;
          }
        } else {
          costElement.textContent = 'MAX LEVEL';
          buyButton.textContent = 'MAXED OUT';
          buyButton.disabled = true;
          reqElement.textContent = 'You have maxed out this upgrade.';
          reqElement.classList.remove('text-red-300'); reqElement.classList.add('text-green-300');
        }
      });
    }

    // =======================================================
    // GAME LOOP
    // =======================================================
    function startGame() {
      stopGame();
      curseModal.style.display = 'none';
      gameOverModal.style.display = 'none';
      isGameOver = false;
      isPausedForCurse = false;
      score = 0;
      obstacles = [];
      coins = [];
      holes = [];
      traps = [];
      isFalling = false;
      obstacleSpawnTimer = 0;
      coinSpawnTimer = 0;
      currentSpeed = BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0);

      // Reset ability state
      jumpCount = 0;
      isHackerAbilityReady = true;
      hackerCooldownRemaining = 0;
      isTimeAbilityReady = true;
      timeCooldownRemaining = 0;
      timeEffectRemaining = 0;
      if (goldenHackerUnlocked) {
        goldenHackerReady = true;
        goldenHackerCooldownRemaining = 0;
      }

      // Reset curse timers for timed curses (per new run)
      activeCurses = activeCurses.filter(c => !c.expiresAt); // keep permanents, drop timed on restart
      curseFogActive = false;
      curseCoinTaxActive = false;
      curseSlipperyActive = false;
      curseDoubleGravityActive = false;
      curseSlowRecoverActive = false;
      curseMagnetMalfunctionActive = false;
      curseObstacleFrenzyActive = false;
      curseTrapStormActive = false;
      curseBlindBarActive = false;
      coinDrainTimer = 0;

      updateHackerButtonUI();
      updateTimeButtonUI();
      updateGoldenHackerButtonUI();

      player = new Player();
      player.setSkin(equippedSkin);
      resizeCanvas();
      canvas.style.borderColor = '#e94560';
      lastTime = 0;
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function stopGame() {
      if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
      persistUserData();
    }

    function gameLoop(currentTime) {
      if (!lastTime) lastTime = currentTime;
      const deltaTime = Math.min(currentTime - lastTime, 100);
      lastTime = currentTime;

      if (isGameOver) { stopGame(); return; }
      if (isPausedForCurse) { animationFrameId = requestAnimationFrame(gameLoop); return; }

      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function update(deltaTime) {
      // Score
      score += deltaTime / 16; // ~60 points/sec
      const uiScore = Math.floor(score / 10);
      scoreElement.textContent = uiScore;

      // Track best level
      bestLevel = Math.max(bestLevel, uiScore);

      // Trigger curse every 100 levels (once per threshold)
      const nextThreshold = Math.floor(uiScore / 100) * 100;
      if (uiScore > 0 && uiScore % 100 === 0 && nextThreshold !== lastCurseThresholdAwarded && !isPausedForCurse) {
        // Pause game for curse selection
        isPausedForCurse = true;
        showCurseChoice();
        return;
      }

      // Speed ramp (consider speed surge permanent)
      const speedFactor = Math.min(uiScore / MAX_SCORE_FOR_SPEED, 1);
      const baseSpeedOffset = (curseSpeedSurgeActive ? 2 : 0);
      const calculatedSpeed = (BASE_GAME_SPEED + baseSpeedOffset) + (MAX_GAME_SPEED_INCREASE * speedFactor);
      if (timeEffectRemaining <= 0) { currentSpeed = calculatedSpeed; canvas.style.borderColor = '#e94560'; }

      // Cooldowns/effects
      if (hackerCooldownRemaining > 0) {
        hackerCooldownRemaining -= deltaTime;
        if (hackerCooldownRemaining <= 0) { hackerCooldownRemaining = 0; isHackerAbilityReady = true; }
        updateHackerButtonUI();
      }
      if (timeCooldownRemaining > 0) {
        timeCooldownRemaining -= deltaTime;
        if (timeCooldownRemaining <= 0) { timeCooldownRemaining = 0; isTimeAbilityReady = true; }
        updateTimeButtonUI();
      }
      if (timeEffectRemaining > 0) {
        timeEffectRemaining -= deltaTime;
        if (timeEffectRemaining <= 0) { timeEffectRemaining = 0; currentSpeed = calculatedSpeed; }
        updateTimeButtonUI();
      }
      if (goldenHackerCooldownRemaining > 0) {
        goldenHackerCooldownRemaining -= deltaTime;
        if (goldenHackerCooldownRemaining <= 0) { goldenHackerCooldownRemaining = 0; goldenHackerReady = true; }
        updateGoldenHackerButtonUI();
      }

      // Update curses timers and effects
      updateCurses(deltaTime);

      // Player physics with dynamic gravity
      const groundY = canvas.height - GROUND_HEIGHT - player.height;
      if (!isFalling) {
        player.velocityY += getDynamicGravity();  // gravity scales slowly
        player.y += player.velocityY;

        // Slippery landing: add slight forward slide
        if (player.y >= groundY) {
          let fallingIntoHole = false;
          for (const hole of holes) {
            if (player.x + player.width > hole.x && player.x < hole.x + hole.width) { fallingIntoHole = true; break; }
          }
          if (fallingIntoHole) { isFalling = true; player.velocityY = 0; }
          else {
            player.y = groundY; player.velocityY = 0; jumpCount = 0;
            if (curseSlipperyActive) {
              player.slideVelocityX = 0.8; // small slide effect
            }
          }
        }

        // Apply slide gradually
        if (player.slideVelocityX > 0) {
          player.x += player.slideVelocityX;
          player.slideVelocityX = Math.max(0, player.slideVelocityX - 0.05);
        }
      } else {
        player.velocityY += getDynamicGravity(3);
        player.y += player.velocityY;
        if (player.y > canvas.height + 50) { gameOver(); return; }
      }

      // Obstacle density ramp (with frenzy curse)
      const initialRate = 100;
      const minRate = MIN_OBSTACLE_RATE;
      const difficultyFactor = Math.min(uiScore / MAX_SCORE_FOR_OBSTACLE_DENSITY, 1);
      const rateReduction = (initialRate - minRate) * difficultyFactor;
      obstacleSpawnRate = initialRate - rateReduction;
      if (curseObstacleFrenzyActive) obstacleSpawnRate = Math.max(minRate, obstacleSpawnRate / 2);

      // Spawning
      obstacleSpawnTimer++;
      if (obstacleSpawnTimer >= obstacleSpawnRate) {
        if (Math.random() < 0.15) holes.push(new Hole());
        else {
          const type = Math.random() < 0.7 ? 'ground' : 'air';
          obstacles.push(new Obstacle(type));
        }
        obstacleSpawnTimer = 0;
      }

      // Traps: rare, start at UI score ‚â• 250; increase rate with trap storm
      const trapProb = TRAP_SPAWN_PROBABILITY * (curseTrapStormActive ? 3 : 1);
      if (uiScore >= TRAP_MIN_UI_SCORE && Math.random() < trapProb) {
        traps.push(new Trap());
      }

      // Coins spawn
      coinSpawnTimer++;
      if (coinSpawnTimer >= COIN_SPAWN_RATE) {
        if (Math.random() < 0.6) coins.push(new Coin());
        coinSpawnTimer = 0;
      }

      // Magnet behavior: malfunction reverses zip direction
      if (magnetLevel > 0 && coins.length > 0) {
        const magnetRadius = MAGNET_UPGRADE.radii[magnetLevel - 1];
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;

        for (let i = coins.length - 1; i >= 0; i--) {
          const coin = coins[i];
          const cx = coin.x + coin.size / 2;
          const cy = coin.y + coin.size / 2;
          const dx = px - cx;
          const dy = py - cy;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const isOverheadX = (coin.x + coin.size > player.x) && (coin.x < player.x + player.width);
          const isHigherY = coin.y < player.y + player.height / 2;

          const shouldZip = magnetLevel === 2
            ? (distance <= magnetRadius)
            : (distance <= magnetRadius && isOverheadX && isHigherY);

          if (shouldZip) {
            if (!curseMagnetMalfunctionActive) {
              coin.x += dx;
              coin.y += dy;
              let value = coin.baseValue;
              if (magnetLevel === 1) value = MAGNET_UPGRADE.values[0];
              else if (magnetLevel === 2) value = MAGNET_UPGRADE.values[1];
              if (curseCoinTaxActive) value = Math.max(0, Math.floor(value * 0.5));
              playerCoins += value;
              coinCountElement.textContent = playerCoins;
              coins.splice(i, 1);
              persistUserData();
            } else {
              // repel
              coin.x -= dx * 0.6;
              coin.y -= dy * 0.6;
            }
          }
        }
      }

      // Obstacles and collisions
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.update();
        if (obs.x + obs.width < 0) { obstacles.splice(i, 1); continue; }
        if (obs.isBypassed) continue;
        if (player.x < obs.x + obs.width &&
            player.x + player.width > obs.x &&
            player.y < obs.y + obs.height &&
            player.y + player.height > obs.y) {
          gameOver(); return;
        }
      }

      // Holes
      for (let i = holes.length - 1; i >= 0; i--) {
        const hole = holes[i];
        hole.update();
        if (hole.x + hole.width < 0) holes.splice(i, 1);
      }

      // Traps ‚Äî snap shut on contact (instant game over)
      for (let i = traps.length - 1; i >= 0; i--) {
        const trap = traps[i];
        trap.update();
        if (trap.x + trap.width < 0) { traps.splice(i, 1); continue; }
        if (!trap.isTriggered &&
            player.x + player.width > trap.x &&
            player.x < trap.x + trap.width &&
            player.y + player.height >= trap.y) {
          trap.isTriggered = true;
          gameOver(); return;
        }
      }

      // Coins (standard overlap)
      for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        coin.update();

        if (player.x < coin.x + coin.size &&
            player.x + player.width > coin.x &&
            player.y < coin.y + coin.size &&
            player.y + player.height > coin.y) {
          let value = coin.baseValue;
          if (magnetLevel === 1) value = MAGNET_UPGRADE.values[0];
          else if (magnetLevel === 2) value = MAGNET_UPGRADE.values[1];
          if (curseCoinTaxActive) value = Math.max(0, Math.floor(value * 0.5));
          playerCoins += value;
          coinCountElement.textContent = playerCoins;
          coins.splice(i, 1);
          persistUserData();
          continue;
        }
        if (coin.x + coin.size < 0) coins.splice(i, 1);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Ground
      ctx.fillStyle = '#2d3748';
      ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

      // Fog overlay if active
      if (curseFogActive) {
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Render order
      holes.forEach(hole => hole.draw());
      traps.forEach(trap => trap.draw());
      obstacles.forEach(obs => obs.draw());
      coins.forEach(coin => coin.draw());
      if (player) player.draw();

      // Blind bar
      if (curseBlindBarActive) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(blindBar.x, 0, blindBar.w, canvas.height);
      }
    }

    function gameOver() {
      isGameOver = true;
      curseModal.style.display = 'none';
      const finalScore = Math.floor(score / 10);
      finalScoreElement.textContent = finalScore;
      if (finalScore > highScore) {
        highScore = finalScore;
        highScoreElement.textContent = highScore;
      }
      bestLevel = Math.max(bestLevel, finalScore);
      persistUserData();
      gameOverModal.style.display = 'flex';
    }

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      if (player) {
        const groundY = canvas.height - GROUND_HEIGHT - player.height;
        if (player.y > groundY && !isFalling) player.y = groundY;
      }
      if (ctx) draw();
    }

    window.addEventListener('load', () => {
      handleInput();
      updateHackerButtonUI();
      updateTimeButtonUI();
      updateGoldenHackerButtonUI();
      window.addEventListener('mouseup', () => player?.crouch(false));
      window.addEventListener('touchend', () => player?.crouch(false));
    });

    // Notes:
    // - Gravity starts at 0.4 and increases slowly toward 1.0 (GRAVITY_SLOW_FACTOR).
    // - Curse system pauses the game every 100 levels for a choice of 3 curses.
    // - Some curses are timed, others are permanent (applied until game over).
    // - Golden skin unlocks Golden Hacker (10s cooldown, golden obstacles, +2 coins).
    // - Skins include previews; shop and leaderboard persist via localStorage.
  </script>
</body>
</html>
