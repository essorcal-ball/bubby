<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stickman Jumper — Arcade Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #111827;
      --accent: #e94560;
      --accent-2: #203463;
      --ground: #2d3748;
      --text: #f9fafb;
      --muted: #9ca3af;
    }
    html, body { height: 100%; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    .panel {
      background: var(--panel);
      border: 2px solid #1c305c;
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    .btn-main {
      background: var(--accent-2);
      border-bottom: 4px solid #1c305c;
      padding: 0.75rem 1.25rem;
      border-radius: 10px;
      font-weight: 700;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }
    .btn-main:hover { background: #294b7b; transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,0.35); }
    .btn-danger { background: #b91c1c; }
    .btn-danger:hover { background: #dc2626; }
    .btn-accent { background: var(--accent); }
    .btn-accent:hover { background: #cf3d54; }
    .btn-muted { background: #334155; }
    .btn-muted:hover { background: #3b495e; }
    .stat {
      background: #0f172a;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    #gameCanvas {
      background: #4a5568;
      border: 4px solid var(--accent);
      border-radius: 14px;
      touch-action: manipulation;
      user-select: none;
    }
    .badge { display:inline-flex; align-items:center; gap:6px; font-size:0.75rem; border-radius:999px; border:1px solid #243b66; background:#16213e; padding:3px 8px; }
    .badge span.dot { width:8px; height:8px; border-radius:999px; display:inline-block; }
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; align-items:center; justify-content:center; z-index:50; }
    .modal-card { max-width:900px; width:95%; }
    .grid-3 { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 12px; }
    .curse-card { background:#132246; border:2px solid #1c305c; padding:12px; border-radius:12px; display:flex; flex-direction:column; gap:10px; }
    .curse-card h4 { font-weight:800; font-size:1rem; }
    .shop-card { background:#132246; border:2px solid #1c305c; padding:16px; border-radius:12px; }
    .skin-preview { border: 1px solid #374151; border-radius: 6px; background: #0b1220; }
    .table { width:100%; border-collapse:collapse; }
    .table thead { background:#0f1a33; }
    .table th, .table td { padding:10px; }
    .row { background:#16213e; }
    .row:nth-child(odd) { background:#132246; }
    .hint { font-size: 0.85rem; color: var(--muted); }
  </style>
</head>
<body>

  <header class="w-full py-3 px-4 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <a href="index.html" class="btn-main btn-muted">← Back to Hub</a>
      <div class="badge"><span class="dot" style="background:#34d399"></span> Shared account data from Hub</div>
    </div>
    <div id="account-bar" class="flex items-center gap-4 stat">
      <div>Player: <span id="account-username" class="font-bold text-yellow-300">—</span></div>
      <div>Coins: <span id="account-coins" class="font-bold text-yellow-300">0</span></div>
      <div>High score: <span id="account-highscore" class="font-bold text-yellow-300">0</span></div>
    </div>
  </header>

  <main class="w-full max-w-6xl mx-auto px-4 pb-24">
    <section class="panel p-4 md:p-6 mb-6">
      <div class="flex flex-wrap items-center justify-between gap-4">
        <h1 class="text-3xl md:text-4xl font-extrabold text-[#e94560] tracking-wide">Stickman Jumper</h1>
        <div class="flex items-center gap-3">
          <button id="restart-btn" class="btn-main btn-accent">Restart</button>
          <button id="quit-btn" class="btn-main btn-danger">Quit to Hub</button>
        </div>
      </div>
      <p class="hint mt-2">Your progress and coins are saved to the shared Hub account. No separate login here.</p>
    </section>

    <section class="grid md:grid-cols-3 gap-6">
      <div class="md:col-span-2 panel p-3 md:p-4">
        <div class="flex flex-wrap items-center justify-between gap-2 mb-3">
          <div class="stat">Score: <span id="ui-score" class="font-bold text-green-300">0</span></div>
          <div class="stat">High: <span id="ui-high" class="font-bold text-yellow-300">0</span></div>
          <div class="stat">Coins: <span id="ui-coins" class="font-bold text-yellow-300">0</span></div>
          <div class="stat">Best level: <span id="ui-best" class="font-bold text-blue-300">0</span></div>
        </div>

        <canvas id="gameCanvas" class="w-full h-96 md:h-[520px]"></canvas>

        <div class="mt-4 flex flex-wrap gap-3">
          <button id="btn-jump" class="btn-main">Jump (Space/Enter)</button>
          <button id="btn-crouch" class="btn-main">Crouch (ArrowDown/S)</button>

          <button id="btn-hacker" class="btn-main relative overflow-hidden" disabled>
            <div id="hacker-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height:100%;"></div>
            <span id="hacker-text" class="relative z-10">Hacker: Buy in Shop</span>
          </button>

          <button id="btn-time" class="btn-main relative overflow-hidden" disabled>
            <div id="time-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height:100%;"></div>
            <span id="time-text" class="relative z-10">Time Warp: Buy</span>
          </button>

          <button id="btn-golden" class="btn-main relative overflow-hidden" disabled>
            <div id="gold-overlay" class="absolute inset-0 bg-red-600 opacity-80 transition-all duration-100 ease-linear" style="height:100%;"></div>
            <span id="gold-text" class="relative z-10">Golden: Buy Golden Skin</span>
          </button>
        </div>

        <div id="game-over-backdrop" class="modal-backdrop">
          <div class="modal-card panel p-6 border-4 border-red-600 text-center">
            <h2 class="text-4xl font-extrabold mb-3">Game Over</h2>
            <p class="text-xl mb-4">Score: <span id="final-score" class="font-bold">0</span></p>
            <div class="flex items-center gap-3 justify-center">
              <button id="btn-try-again" class="btn-main btn-accent">Try Again</button>
              <a href="index.html" class="btn-main btn-muted">Back to Hub</a>
            </div>
          </div>
        </div>

        <div id="curse-backdrop" class="modal-backdrop">
          <div class="modal-card panel border-4 border-[#e94560] p-5">
            <h3 class="text-2xl font-extrabold mb-2">Choose your curse</h3>
            <p class="hint mb-4">Every 100 levels, pick a curse. Some last for a duration, some are permanent.</p>
            <div id="curse-options" class="grid-3"></div>
            <div class="flex justify-end mt-3">
              <button class="btn-main btn-muted opacity-60 cursor-not-allowed">Skip (disabled)</button>
            </div>
          </div>
        </div>
      </div>

      <aside class="panel p-4">
        <h3 class="text-xl font-bold mb-3">Upgrades & Skins (Read-only)</h3>
        <p class="hint mb-4">Manage purchases in the Hub’s shop. This panel reflects your unlocked levels here.</p>

        <div class="shop-card mb-3">
          <h4 class="text-lg font-bold text-blue-300 mb-2">Time Warp</h4>
          <p>Level: <span id="time-level" class="font-bold text-green-300">0</span></p>
          <p id="time-effect" class="hint mt-1">Effect: Not yet purchased.</p>
        </div>
        <div class="shop-card mb-3">
          <h4 class="text-lg font-bold text-purple-300 mb-2">Hacker</h4>
          <p>Level: <span id="hacker-level" class="font-bold text-green-300">0</span></p>
          <p id="hacker-effect" class="hint mt-1">Effect: Not yet purchased.</p>
        </div>
        <div class="shop-card mb-3">
          <h4 class="text-lg font-bold text-green-300 mb-2">Jump</h4>
          <p>Level: <span id="jump-level" class="font-bold text-green-300">0</span></p>
          <p id="jump-effect" class="hint mt-1">Standard single jump.</p>
        </div>
        <div class="shop-card mb-3">
          <h4 class="text-lg font-bold text-yellow-300 mb-2">Magnet</h4>
          <p>Level: <span id="magnet-level" class="font-bold text-green-300">0</span></p>
          <p id="magnet-effect" class="hint mt-1">No magnet. Coins worth 1.</p>
        </div>
        <div class="shop-card mb-3">
          <h4 class="text-lg font-bold text-pink-300 mb-2">Curse Bender</h4>
          <p>Level: <span id="curseBender-level" class="font-bold text-green-300">0</span></p>
          <p id="curseBender-effect" class="hint mt-1">No curse protection.</p>
        </div>

        <div class="shop-card">
          <h4 class="text-lg font-bold text-red-300 mb-2">Skins</h4>
          <div id="skins-list" class="space-y-3"></div>
        </div>
      </aside>
    </section>

    <section class="panel p-4 mt-6">
      <h3 class="text-xl font-bold">Patch Notes</h3>
      <ul class="list-disc pl-6 mt-2 text-sm text-gray-300">
        <li>Speed ramp slowed, obstacle density increases more gently.</li>
        <li>Enforced obstacle spacing; flying obstacles spawn away from red ground blocks.</li>
        <li>Fog curse made heavier for visibility challenge.</li>
        <li>Traps blend with floor and only trigger when you stand on them; hidden until stepped.</li>
        <li>Trap and hole false positives reduced with tightened collision checks and hole width clamp.</li>
        <li>Shared account data from Hub; this page is login-free and read-only for shop.</li>
      </ul>
    </section>
  </main>

  <script>
    // -------------------------------------------------------
    // Hub Account Bridge
    // -------------------------------------------------------
    function hubGetCurrentUser() {
      return localStorage.getItem("arcadeCurrentUser") || null;
    }
    function hubGetUserData(username) {
      const raw = localStorage.getItem("arcadeUser_" + username);
      return raw ? JSON.parse(raw) : null;
    }
    function hubSaveUserData(username, data) {
      localStorage.setItem("arcadeUser_" + username, JSON.stringify(data));
    }

    // -------------------------------------------------------
    // Shared State
    // -------------------------------------------------------
    let currentUsername = null;
    let userData = null;

    // Game state
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GROUND_HEIGHT = 58;
    const PLAYER_SIZE = 42;

    const BASE_GAME_SPEED = 4.0;
    const MAX_GAME_SPEED_INCREASE = 8.0;
    const MAX_SCORE_FOR_SPEED = 400;

    const BASE_GRAVITY_START = 0.42;
    const MAX_GRAVITY = 1.05;
    const GRAVITY_SLOW_FACTOR = 1.5;

    const JUMP_VELOCITY = -12.2;

    const MAX_SCORE_FOR_OBSTACLE_DENSITY = 360;
    let obstacleSpawnRate = 110;
    const MIN_OBSTACLE_RATE = 42;
    const MIN_OBSTACLE_SPACING = 150;

    let player;
    let obstacles = [];
    let holes = [];
    let coins = [];
    let traps = [];
    let score = 0;
    let bestLevel = 0;
    let highScore = 0;
    let currentSpeed = BASE_GAME_SPEED;
    let isGameOver = false;
    let isPausedForCurse = false;
    let lastCurseThresholdAwarded = 0;
    let obstacleSpawnTimer = 0;
    let coinSpawnTimer = 0;
    const COIN_SPAWN_RATE = 380;

    // Upgrades (read-only here, updated from hub)
    let playerCoins = 0;
    let timeLevel = 0;
    let hackerLevel = 0;
    let jumpLevel = 0;
    let magnetLevel = 0;
    let curseBenderLevel = 0;

    let jumpCount = 0;
    let isFalling = false;

    let isHackerAbilityReady = true;
    let hackerCooldownRemaining = 0;
    let isTimeAbilityReady = true;
    let timeCooldownRemaining = 0;
    let timeEffectRemaining = 0;

    const GOLDEN_HACKER_UPGRADE = { cooldown: 10000 };
    let goldenHackerUnlocked = false;
    let goldenHackerCooldownRemaining = 0;
    let goldenHackerReady = true;

    const TRAP_SPAWN_PROBABILITY = 0.015;
    const TRAP_MIN_UI_SCORE = 250;

    const magnetForce = 0.025;

    // Curses
    let activeCurses = [];
    let curseTimers = {};
    let curseFogActive = false;
    let curseCoinTaxActive = false;
    let curseSlipActive = false;
    let slipTimer = 0;
    let curseDoubleGravityActive = false;
    let curseSlowRecoverActive = false;
    let curseMagnetMalfunctionActive = false;
    let curseObstacleFrenzyActive = false;
    let curseTrapStormActive = false;
    let curseBlindBarActive = false;
    let cursePermanentGravityBoost = 0;
    let curseCoinDrainActive = false;
    let curseSpeedSurgeActive = false;
    const blindBar = { x: 0, w: 80 };
    let coinDrainTimer = 0;

    // Skins
    const SKINS = [
      { id: 'default', name: 'Default', cost: 0 },
      { id: 'santa',  name: 'Santa',   cost: 5 },
      { id: 'ninja',  name: 'Ninja',   cost: 10 },
      { id: 'robot',  name: 'Robot',   cost: 15 },
      { id: 'pirate', name: 'Pirate',  cost: 20 },
      { id: 'alien',  name: 'Alien',   cost: 25 },
      { id: 'golden', name: 'Golden',  cost: 100 }
    ];
    let ownedSkins = { default: true };
    let equippedSkin = 'default';

    // -------------------------------------------------------
    // UI Elements
    // -------------------------------------------------------
    const accountUsernameEl = document.getElementById('account-username');
    const accountCoinsEl = document.getElementById('account-coins');
    const accountHighEl = document.getElementById('account-highscore');

    const uiScoreEl = document.getElementById('ui-score');
    const uiHighEl = document.getElementById('ui-high');
    const uiCoinsEl = document.getElementById('ui-coins');
    const uiBestEl = document.getElementById('ui-best');

    const timeLevelEl = document.getElementById('time-level');
    const hackerLevelEl = document.getElementById('hacker-level');
    const jumpLevelEl = document.getElementById('jump-level');
    const magnetLevelEl = document.getElementById('magnet-level');
    const curseBenderLevelEl = document.getElementById('curseBender-level');

    const timeEffectEl = document.getElementById('time-effect');
    const hackerEffectEl = document.getElementById('hacker-effect');
    const jumpEffectEl = document.getElementById('jump-effect');
    const magnetEffectEl = document.getElementById('magnet-effect');
    const curseBenderEffectEl = document.getElementById('curseBender-effect');

    const skinsListEl = document.getElementById('skins-list');

    const btnJump = document.getElementById('btn-jump');
    const btnCrouch = document.getElementById('btn-crouch');
    const btnHacker = document.getElementById('btn-hacker');
    const btnTime = document.getElementById('btn-time');
    const btnGolden = document.getElementById('btn-golden');

    const hackerOverlay = document.getElementById('hacker-overlay');
    const hackerText = document.getElementById('hacker-text');
    const timeOverlay = document.getElementById('time-overlay');
    const timeText = document.getElementById('time-text');
    const goldOverlay = document.getElementById('gold-overlay');
    const goldText = document.getElementById('gold-text');

    const gameOverBackdrop = document.getElementById('game-over-backdrop');
    const finalScoreEl = document.getElementById('final-score');

    const curseBackdrop = document.getElementById('curse-backdrop');
    const curseOptionsEl = document.getElementById('curse-options');

    const restartBtn = document.getElementById('restart-btn');
    const quitBtn = document.getElementById('quit-btn');
    const tryAgainBtn = document.getElementById('btn-try-again');

    // -------------------------------------------------------
    // Upgrade info (read-only text)
    // -------------------------------------------------------
    const TIME_UPGRADE = {
      cooldowns: [30000, 20000, 35000],
      effectDuration: [4000, 5000, 6000],
      slowdownFactor: [0.7, 0.5, 'BASE'],
      effect: (lvl) => {
        if (lvl === 0) return 'Effect: Not yet purchased.';
        const cd = TIME_UPGRADE.cooldowns[lvl - 1] / 1000;
        if (lvl === 3) return `Cooldown: ${cd}s. Resets speed to base for ${TIME_UPGRADE.effectDuration[lvl-1]/1000}s.`;
        const factor = TIME_UPGRADE.slowdownFactor[lvl-1];
        return `Cooldown: ${cd}s. Slows speed to ${Math.floor(factor * 100)}% for ${TIME_UPGRADE.effectDuration[lvl-1]/1000}s.`;
      }
    };
    const HACKER_UPGRADE = {
      cooldowns: [9000, 13000, 16000],
      effect: (lvl) => {
        if (lvl === 0) return 'Effect: Not yet purchased.';
        if (lvl === 1) return 'Cooldown: 9s. Bypasses 1 obstacle.';
        if (lvl === 2) return 'Cooldown: 13s. Bypasses 2 obstacles.';
        if (lvl === 3) return 'Cooldown: 16s. Bypasses 3 obstacles & holes.';
      }
    };
    const JUMP_UPGRADE = {
      maxLevels: [2, 3],
      effect: (lvl) => {
        if (lvl === 0) return 'Standard single jump.';
        if (lvl === 1) return `Double Jump (${JUMP_UPGRADE.maxLevels[0]} jumps).`;
        if (lvl === 2) return `Triple Jump (${JUMP_UPGRADE.maxLevels[1]} jumps).`;
      }
    };
    const MAGNET_UPGRADE = {
      values: [2, 3],
      radii: [150, 300],
      effect: (lvl) => {
        if (lvl === 0) return 'No magnet. Coins worth 1.';
        if (lvl === 1) return 'Magnet active. Coins worth 2x.';
        if (lvl === 2) return 'Strong magnet. Coins worth 3x.';
      }
    };
    const CURSE_BENDER_UPGRADE = {
      effect: (lvl) => {
        if (lvl === 0) return 'No curse protection.';
        if (lvl === 1) return 'Blocks Very Horrible curses.';
        if (lvl === 2) return 'Blocks Horrible curses.';
        if (lvl === 3) return 'Blocks Bad curses.';
      }
    };

    // -------------------------------------------------------
    // Curses definitions
    // -------------------------------------------------------
    const CURSES = [
      // Not so bad
      { id: 'fog', name: 'Foggy Vision', rating: 'Not so bad', duration: 30000,
        description: 'Heavy fog reduces visibility for 30s.',
        apply: () => { curseFogActive = true; },
        cleanup: () => { curseFogActive = false; }
      },
      { id: 'coinTax', name: 'Coin Tax', rating: 'Not so bad', duration: 20000,
        description: 'Coins grant half value for 20s.',
        apply: () => { curseCoinTaxActive = true; },
        cleanup: () => { curseCoinTaxActive = false; }
      },
      { id: 'slippery', name: 'Slippery Feet', rating: 'Not so bad', duration: 2000,
        description: 'The world speeds up briefly, like slipping.',
        apply: () => { curseSlipActive = true; slipTimer = 2000; },
        cleanup: () => { curseSlipActive = false; slipTimer = 0; }
      },

      // Bad
      { id: 'doubleGravity', name: 'Double Gravity', rating: 'Bad', duration: 15000,
        description: 'Gravity doubles for 15s.',
        apply: () => { curseDoubleGravityActive = true; },
        cleanup: () => { curseDoubleGravityActive = false; }
      },
      { id: 'slowRecover', name: 'Slow Recovery', rating: 'Bad', duration: 20000,
        description: 'Crouch recovery becomes sluggish for 20s.',
        apply: () => { curseSlowRecoverActive = true; },
        cleanup: () => { curseSlowRecoverActive = false; }
      },
      { id: 'magnetMalfunction', name: 'Magnet Malfunction', rating: 'Bad', duration: 20000,
        description: 'Magnet repels coins for 20s.',
        apply: () => { curseMagnetMalfunctionActive = true; },
        cleanup: () => { curseMagnetMalfunctionActive = false; }
      },

      // Horrible
      { id: 'obstacleFrenzy', name: 'Obstacle Frenzy', rating: 'Horrible', duration: 30000,
        description: 'Obstacle spawn rate doubles for 30s.',
        apply: () => { curseObstacleFrenzyActive = true; },
        cleanup: () => { curseObstacleFrenzyActive = false; }
      },
      { id: 'trapStorm', name: 'Trap Storm', rating: 'Horrible', duration: 25000,
        description: 'Traps spawn much more frequently for 25s.',
        apply: () => { curseTrapStormActive = true; },
        cleanup: () => { curseTrapStormActive = false; }
      },
      { id: 'blindBar', name: 'Blind Spot', rating: 'Horrible', duration: 25000,
        description: 'A black bar blocks part of your view for 25s.',
        apply: () => { curseBlindBarActive = true; blindBar.x = Math.random() * 200 + 80; blindBar.w = 80 + Math.random()*80; },
        cleanup: () => { curseBlindBarActive = false; }
      },

      // Very Horrible (permanent)
      { id: 'permGravity', name: 'Permanent Gravity Boost', rating: 'Very Horrible', duration: null,
        description: 'Gravity permanently increases by +0.3.',
        apply: () => { cursePermanentGravityBoost += 0.3; },
        cleanup: () => {}
      },
      { id: 'coinDrain', name: 'Coin Drain', rating: 'Very Horrible', duration: null,
        description: 'Lose 1 coin every 5 seconds until game over.',
        apply: () => { curseCoinDrainActive = true; coinDrainTimer = 0; },
        cleanup: () => {}
      },
      { id: 'speedSurge', name: 'Speed Surge', rating: 'Very Horrible', duration: null,
        description: 'Base speed permanently increases by +2.',
        apply: () => { curseSpeedSurgeActive = true; },
        cleanup: () => {}
      }
    ];

    function filteredCursePool() {
      let pool = [...CURSES];
      if (curseBenderLevel >= 1) pool = pool.filter(c => c.rating !== 'Very Horrible');
      if (curseBenderLevel >= 2) pool = pool.filter(c => c.rating !== 'Horrible');
      if (curseBenderLevel >= 3) pool = pool.filter(c => c.rating !== 'Bad');
      return pool;
    }

    function pickRandomCurses(count = 3) {
      let pool = filteredCursePool();
      const picks = [];
      for (let i = 0; i < count && pool.length > 0; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        picks.push(pool[idx]);
        pool.splice(idx, 1);
      }
      if (picks.length < count) {
        const safePool = CURSES.filter(c => c.rating === 'Not so bad');
        while (picks.length < count && safePool.length > 0) {
          const idx2 = Math.floor(Math.random() * safePool.length);
          picks.push(safePool[idx2]);
          safePool.splice(idx2, 1);
        }
      }
      return picks;
    }

    function showCurseModal() {
      isPausedForCurse = true;
      curseBackdrop.style.display = 'flex';
      curseOptionsEl.innerHTML = '';
      const options = pickRandomCurses(3);
      options.forEach(c => {
        const div = document.createElement('div');
        div.className = 'curse-card';
        div.innerHTML = `
          <div class="flex items-center justify-between">
            <h4>${c.name}</h4>
            <div class="badge"><span class="dot" style="background:${c.rating==='Not so bad'?'#10b981':c.rating==='Bad'?'#f59e0b':c.rating==='Horrible'?'#ef4444':'#7c3aed'}"></span>${c.rating}</div>
          </div>
          <p class="hint">${c.description}</p>
          <p class="hint">${c.duration ? 'Duration: ' + Math.floor(c.duration/1000) + 's' : 'Permanent'}</p>
          <button class="btn-main btn-accent">Choose</button>
        `;
        const btn = div.querySelector('button');
        btn.addEventListener('click', () => applyCurse(c));
        curseOptionsEl.appendChild(div);
      });
    }

    function applyCurse(curse) {
      curse.apply();
      const now = performance.now();
      activeCurses.push({ id: curse.id, name: curse.name, rating: curse.rating, expiresAt: curse.duration ? now + curse.duration : null });
      if (curse.duration) curseTimers[curse.id] = curse.duration;

      obstacles = [];
      holes = [];
      traps = [];
      coins = [];
      obstacleSpawnTimer = 0;
      coinSpawnTimer = 0;

      curseBackdrop.style.display = 'none';
      isPausedForCurse = false;
      lastCurseThresholdAwarded = Math.floor((score/10) / 100) * 100;
    }

    function updateCurses(delta) {
      if (activeCurses.length === 0 && !curseCoinDrainActive && !curseSlipActive) return;
      const now = performance.now();
      for (let i = activeCurses.length - 1; i >= 0; i--) {
        const c = activeCurses[i];
        if (c.expiresAt && now >= c.expiresAt) {
          const def = CURSES.find(x => x.id === c.id);
          if (def && def.cleanup) def.cleanup();
          delete curseTimers[c.id];
          activeCurses.splice(i, 1);
        } else if (c.expiresAt) {
          curseTimers[c.id] = Math.max(0, curseTimers[c.id] - delta);
        }
      }
      if (curseCoinDrainActive) {
        coinDrainTimer += delta;
        if (coinDrainTimer >= 5000) {
          coinDrainTimer = 0;
          if (playerCoins > 0) {
            playerCoins -= 1;
            uiCoinsEl.textContent = playerCoins;
            saveBackToHub();
          }
        }
      }
      if (curseSlipActive) {
        slipTimer -= delta;
        if (slipTimer <= 0) { curseSlipActive = false; slipTimer = 0; }
      }
    }

    // -------------------------------------------------------
    // Drawing helpers: stickman skins
    // -------------------------------------------------------
    const DEFAULT_GOLD = '#f4c542';
    const NINJA_BAND_RED = '#d81e1e';
    const ALIEN_GREEN = '#00ff00';
    const ROBOT_GRAY = '#8a8a8a';
    const ROBOT_EYE_CYAN = '#00e1ff';
    const PIRATE_BLACK = '#000000';
    const PIRATE_STRIPE_RED = '#d81e1e';
    const PIRATE_STRIPE_BROWN = '#7b3f00';
    const SANTA_RED = '#ff0000';
    const SANTA_WHITE = '#ffffff';
    const GOLDEN_LINE = '#f4c542';

    function drawStickmanLines(ctx, x, y, w, h, color, lineWidth=3) {
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      ctx.beginPath(); ctx.arc(x + w / 2, y + 5, 6, 0, Math.PI * 2); ctx.stroke();
      const bodyTop = y + 12;
      const bodyBottom = y + h - 10;
      ctx.beginPath(); ctx.moveTo(x + w / 2, bodyTop); ctx.lineTo(x + w / 2, bodyBottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, y + (h/2 - 5)); ctx.lineTo(x + w, y + (h/2 - 5)); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w / 2, bodyBottom); ctx.lineTo(x, y + h);
      ctx.moveTo(x + w / 2, bodyBottom); ctx.lineTo(x + w, y + h);
      ctx.stroke();
    }
    function drawDefault(ctx, x, y, w, h) { drawStickmanLines(ctx, x, y, w, h, DEFAULT_GOLD, 3.5); }
    function drawGolden(ctx, x, y, w, h) { drawStickmanLines(ctx, x, y, w, h, GOLDEN_LINE, 3.5); }
    function drawAlien(ctx, x, y, w, h) { drawStickmanLines(ctx, x, y, w, h, ALIEN_GREEN, 3.5); }
    function drawRobot(ctx, x, y, w, h) {
      drawStickmanLines(ctx, x, y, w, h, ROBOT_GRAY, 3.5);
      const hx = x + w/2, hy = y + 5;
      ctx.fillStyle = ROBOT_EYE_CYAN;
      ctx.beginPath(); ctx.ellipse(hx - 3, hy, 2, 3, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(hx + 3, hy, 2, 3, 0, 0, Math.PI*2); ctx.fill();
    }
    function drawNinja(ctx, x, y, w, h) {
      drawStickmanLines(ctx, x, y, w, h, '#000000', 3.5);
      const cx = x + w/2, cy = y + 5, r = 6;
      ctx.strokeStyle = NINJA_BAND_RED; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.arc(cx, cy, r, Math.PI*0.15, Math.PI*1.85); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, r+2, Math.PI*0.15, Math.PI*1.85); ctx.stroke();
      ctx.fillStyle = NINJA_BAND_RED;
      ctx.beginPath(); ctx.arc(x + w/2 - r - 2, cy, 2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = NINJA_BAND_RED; ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x + w/2 - r - 2, cy);
      ctx.quadraticCurveTo(x + w/2 - r - 12, cy - 6, x + w/2 - r - 18, cy - 2);
      ctx.quadraticCurveTo(x + w/2 - r - 10, cy + 6, x + w/2 - r - 18, cy + 10);
      ctx.stroke();
    }
    function drawPirate(ctx, x, y, w, h) {
      drawStickmanLines(ctx, x, y, w, h, PIRATE_BLACK, 3.5);
      const cx = x + w/2, cy = y - 2;
      ctx.fillStyle = PIRATE_BLACK;
      ctx.fillRect(cx - 14, cy, 28, 4);
      ctx.beginPath();
      ctx.moveTo(cx - 10, cy);
      ctx.quadraticCurveTo(cx, cy - 10, cx + 10, cy);
      ctx.lineTo(cx + 10, cy + 8);
      ctx.lineTo(cx - 10, cy + 8);
      ctx.closePath(); ctx.fill();
      const bodyTop = y + 12, bodyBottom = y + h - 10;
      ctx.strokeStyle = PIRATE_STRIPE_RED; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x + w/2 - 5, bodyTop); ctx.lineTo(x + w/2 - 5, bodyBottom); ctx.stroke();
      ctx.strokeStyle = PIRATE_STRIPE_BROWN;
      ctx.beginPath(); ctx.moveTo(x + w/2 + 5, bodyTop); ctx.lineTo(x + w/2 + 5, bodyBottom); ctx.stroke();
    }
    function drawSanta(ctx, x, y, w, h) {
      drawStickmanLines(ctx, x, y, w, h, SANTA_RED, 3.5);
      ctx.strokeStyle = SANTA_WHITE; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x + 4, y + (h/2 - 5)); ctx.lineTo(x + 8, y + (h/2 - 5)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x + w - 8, y + (h/2 - 5)); ctx.lineTo(x + w - 4, y + (h/2 - 5)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x + 6, y + h - 2); ctx.lineTo(x + 10, y + h - 2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x + w - 10, y + h - 2); ctx.lineTo(x + w - 6, y + h - 2); ctx.stroke();
      const hx = x + w/2, hy = y - 2;
      ctx.fillStyle = SANTA_RED;
      ctx.beginPath();
      ctx.moveTo(hx - 10, hy);
      ctx.quadraticCurveTo(hx + 2, hy - 12, hx + 12, hy - 4);
      ctx.lineTo(hx + 12, hy);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = SANTA_WHITE; ctx.fillRect(hx - 12, hy, 24, 3);
      ctx.beginPath(); ctx.arc(hx + 12, hy - 4, 3, 0, Math.PI*2); ctx.fill();
    }

    // -------------------------------------------------------
    // Classes
    // -------------------------------------------------------
    class Player {
      constructor() {
        this.width = PLAYER_SIZE / 2;
        this.height = PLAYER_SIZE;
        this.x = 52;
        this.y = canvas.height - GROUND_HEIGHT - this.height;
        this.vy = 0;
        this.isCrouching = false;
        this.skin = equippedSkin;
      }
      setSkin(name) { this.skin = name; }
      crouch(on) {
        this.isCrouching = on;
        const targetHeight = on ? PLAYER_SIZE / 2 : PLAYER_SIZE;
        if (curseSlowRecoverActive && !on) {
          setTimeout(() => {
            this.height = targetHeight;
            this.y = canvas.height - GROUND_HEIGHT - this.height;
          }, 250);
        } else {
          this.height = targetHeight;
          this.y = canvas.height - GROUND_HEIGHT - this.height;
        }
      }
      jump() {
        if (!isGameOver && !isFalling && !this.isCrouching) {
          let maxJumps = 1;
          if (jumpLevel === 1) maxJumps = JUMP_UPGRADE.maxLevels[0];
          if (jumpLevel === 2) maxJumps = JUMP_UPGRADE.maxLevels[1];
          if (jumpCount < maxJumps) {
            this.vy = JUMP_VELOCITY;
            jumpCount++;
          }
        }
      }
      draw() {
        const x = this.x, y = this.y, w = this.width, h = this.height;
        switch (this.skin) {
          case 'ninja':  drawNinja(ctx, x, y, w, h); break;
          case 'alien':  drawAlien(ctx, x, y, w, h); break;
          case 'robot':  drawRobot(ctx, x, y, w, h); break;
          case 'pirate': drawPirate(ctx, x, y, w, h); break;
          case 'santa':  drawSanta(ctx, x, y, w, h); break;
          case 'golden': drawGolden(ctx, x, y, w, h); break;
          default:       drawDefault(ctx, x, y, w, h);
        }
      }
    }

    class Coin {
      constructor() {
        this.size = 15;
        this.x = canvas.width;
        this.color = '#FFD700';
        this.baseValue = 1;
        const level = Math.floor(Math.random() * 3);
        if (level === 0) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 3.7;
        else if (level === 1) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 1.6;
        else this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 0.6;
      }
      update(speed) { this.x -= speed; }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Obstacle {
      constructor(type) {
        this.type = type;
        this.width = 20 + Math.random() * 20;
        this.defaultColor = type === 'ground' ? '#ff6b6b' : '#647DEE';
        this.color = this.defaultColor;
        this.isBypassed = false;
        if (type === 'ground') {
          this.height = 20 + Math.random() * 30;
          this.x = canvas.width;
          this.y = canvas.height - GROUND_HEIGHT - this.height;
        } else {
          this.height = 15;
          this.width = 40 + Math.random() * 30;
          this.x = canvas.width;
          this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE * 2.8 - Math.random() * 60;
          this.vy = 0.25;
        }
      }
      update(speed) {
        this.x -= speed;
        if (this.type === 'air' && Math.floor(score / 10) >= 250) {
          this.y += this.vy;
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        if (this.type === 'ground' && this.color === this.defaultColor) {
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(this.x, canvas.height - GROUND_HEIGHT, this.width, 10);
        }
      }
    }

    class Hole {
      constructor() {
        const baseWidth = 75;
        const randomExtra = Math.random() * 75;
        const uiScore = Math.floor(score / 10);
        const scaling = Math.min(uiScore / 220, 3);
        this.width = Math.min((baseWidth + randomExtra) * (1 + scaling * 0.25), 200);
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT;
        this.height = GROUND_HEIGHT;
        this.isHazard = true;
        this.isBypassed = false;
        this.color = '#16213e';
      }
      update(speed) { this.x -= speed; }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeStyle = '#0f172a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.width, this.y);
        ctx.stroke();
      }
    }

    class Trap {
      constructor() {
        this.width = 75 + Math.random() * 75;
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT;
        this.height = GROUND_HEIGHT;
        this.isTriggered = false;
        this.color = '#2d3748';
        this.tintAlpha = 0.04;
        this.animationProgress = 0;
      }
      update(speed) {
        this.x -= speed;
        if (this.isTriggered && this.animationProgress < 1) {
          this.animationProgress += 0.06;
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        if (!this.isTriggered) {
          ctx.fillStyle = `rgba(255,0,0,${this.tintAlpha})`;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          return;
        }
        const spikeHeight = 20;
        const spikeWidth = 6;
        const spacing = 20;
        const numSpikes = Math.floor(this.width / spacing);
        const baseY = this.y;
        for (let i = 0; i < numSpikes; i++) {
          const baseX = this.x + i * spacing + 5;
          const rise = spikeHeight * this.animationProgress;
          ctx.fillStyle = '#2b2f3a';
          ctx.beginPath();
          ctx.moveTo(baseX, baseY);
          ctx.lineTo(baseX + spikeWidth / 2, baseY - rise);
          ctx.lineTo(baseX + spikeWidth, baseY);
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // -------------------------------------------------------
    // Abilities
    // -------------------------------------------------------
    function activateHackerAbility() {
      if (hackerLevel === 0 || !isHackerAbilityReady || isGameOver || isPausedForCurse) return;
      isHackerAbilityReady = false;
      hackerCooldownRemaining = HACKER_UPGRADE.cooldowns[hackerLevel - 1];

      let bypassCount = 1;
      if (hackerLevel === 2) bypassCount = 2;
      if (hackerLevel === 3) bypassCount = 3;

      let targets = obstacles.filter(obs => obs.x > player.x && !obs.isBypassed);
      if (hackerLevel === 3) {
        const holeTargets = holes.filter(h => !h.isBypassed && h.x > player.x);
        targets = targets.concat(holeTargets);
      }

      for (let i = 0; i < bypassCount && i < targets.length; i++) {
        const target = targets[i];
        if (target instanceof Obstacle) {
          target.isBypassed = true;
          target.color = '#059669';
        } else if (target instanceof Hole) {
          target.isBypassed = true;
          target.color = '#34d399';
        }
      }
      updateHackerButtonUI();
    }

    function activateTimeAbility() {
      if (timeLevel === 0 || !isTimeAbilityReady || isGameOver || isPausedForCurse) return;
      isTimeAbilityReady = false;
      timeCooldownRemaining = TIME_UPGRADE.cooldowns[timeLevel - 1];
      const factor = TIME_UPGRADE.slowdownFactor[timeLevel - 1];
      currentSpeed = factor === 'BASE' ? BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0) : currentSpeed * factor;
      timeEffectRemaining = TIME_UPGRADE.effectDuration[timeLevel - 1];
      canvas.style.borderColor = '#60a5fa';
      updateTimeButtonUI();
    }

    function activateGoldenHacker() {
      if (!goldenHackerUnlocked || !goldenHackerReady || isGameOver || isPausedForCurse) return;
      goldenHackerReady = false;
      goldenHackerCooldownRemaining = GOLDEN_HACKER_UPGRADE.cooldown;

      const target = obstacles.find(obs => obs.x > player.x && !obs.isBypassed);
      if (target) {
        target.isBypassed = true;
        target.color = '#FFD700';
        playerCoins += 2;
        uiCoinsEl.textContent = playerCoins;
        saveBackToHub();
      }
      updateGoldenHackerButtonUI();
    }

    function updateHackerButtonUI() {
      if (hackerLevel === 0) {
        btnHacker.disabled = true; hackerText.textContent = 'Hacker: Buy in Shop'; hackerOverlay.style.height = '100%'; return;
      }
      if (isHackerAbilityReady && !isPausedForCurse) {
        btnHacker.disabled = false; hackerText.textContent = 'Hacker READY (X)'; hackerOverlay.style.height = '0%';
      } else {
        btnHacker.disabled = true;
        const total = HACKER_UPGRADE.cooldowns[hackerLevel - 1];
        const remainingSec = Math.ceil(hackerCooldownRemaining / 1000);
        const percent = (hackerCooldownRemaining / total) * 100;
        hackerText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        hackerOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }
    function updateTimeButtonUI() {
      if (timeLevel === 0) { btnTime.disabled = true; timeText.textContent = 'Time Warp: Buy'; timeOverlay.style.height = '100%'; return; }
      if (timeEffectRemaining > 0) {
        btnTime.disabled = true;
        const remainingSec = Math.ceil(timeEffectRemaining / 1000);
        timeText.textContent = `WARP: ${remainingSec}s`;
        timeOverlay.style.height = '0%';
        return;
      }
      if (isTimeAbilityReady && !isPausedForCurse) {
        btnTime.disabled = false; timeText.textContent = 'Time READY (T)'; timeOverlay.style.height = '0%';
      } else {
        btnTime.disabled = true;
        const total = TIME_UPGRADE.cooldowns[timeLevel - 1];
        const remainingSec = Math.ceil(timeCooldownRemaining / 1000);
        const percent = (timeCooldownRemaining / total) * 100;
        timeText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        timeOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }
    function updateGoldenHackerButtonUI() {
      if (!goldenHackerUnlocked) { btnGolden.disabled = true; goldText.textContent = 'Golden: Buy Golden Skin'; goldOverlay.style.height = '100%'; return; }
      if (goldenHackerReady && !isPausedForCurse) {
        btnGolden.disabled = false; goldText.textContent = 'Golden READY (G)'; goldOverlay.style.height = '0%';
      } else {
        btnGolden.disabled = true;
        const total = GOLDEN_HACKER_UPGRADE.cooldown;
        const remainingSec = Math.ceil(goldenHackerCooldownRemaining / 1000);
        const percent = (goldenHackerCooldownRemaining / total) * 100;
        goldText.textContent = isPausedForCurse ? 'PAUSED' : `${remainingSec}s`;
        goldOverlay.style.height = isPausedForCurse ? '100%' : `${percent}%`;
      }
    }

    // -------------------------------------------------------
    // Input
    // -------------------------------------------------------
    function bindInput() {
      document.addEventListener('keydown', (e) => {
        if (!isGameOver && !isPausedForCurse) {
          if (e.code === 'Space' || e.code === 'Enter') player.jump();
          if (e.key === 'x' || e.key === 'X') activateHackerAbility();
          if (e.key === 't' || e.key === 'T') activateTimeAbility();
          if (e.key === 'g' || e.key === 'G') activateGoldenHacker();
          if (e.key === 'ArrowDown' || e.key === 's') player.crouch(true);
        }
      });
      document.addEventListener('keyup', (e) => { if (e.key === 'ArrowDown' || e.key === 's') player.crouch(false); });
      btnJump.addEventListener('click', () => { if (!isGameOver && !isPausedForCurse) player.jump(); });
      btnCrouch.addEventListener('mousedown', () => !isPausedForCurse && player.crouch(true));
      btnCrouch.addEventListener('mouseup', () => player.crouch(false));
      btnCrouch.addEventListener('mouseleave', () => player.crouch(false));
      btnCrouch.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isPausedForCurse) player.crouch(true); });
      btnCrouch.addEventListener('touchend', (e) => { e.preventDefault(); player.crouch(false); });

      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isGameOver && !isPausedForCurse) player.jump(); });

      btnHacker.addEventListener('click', activateHackerAbility);
      btnTime.addEventListener('click', activateTimeAbility);
      btnGolden.addEventListener('click', activateGoldenHacker);

      restartBtn.addEventListener('click', () => { startGame(); });
      tryAgainBtn.addEventListener('click', () => { startGame(); });
      quitBtn.addEventListener('click', () => { window.location.href = 'index.html'; });
    }

    // -------------------------------------------------------
    // Spawn helpers
    // -------------------------------------------------------
    function lastObstacleX() {
      if (obstacles.length === 0) return -Infinity;
      return obstacles[obstacles.length - 1].x;
    }
    function canSpawnObstacle() { return (canvas.width - lastObstacleX()) > MIN_OBSTACLE_SPACING; }
    function closestGroundObstacleDistance() {
      let minDist = Infinity;
      for (const o of obstacles) {
        if (o.type === 'ground') {
          const dist = canvas.width - o.x;
          if (dist < minDist) minDist = dist;
        }
      }
      return minDist;
    }
    function canSpawnAirObstacleFarFromGround(threshold = 220) { return closestGroundObstacleDistance() > threshold; }
    function canSpawnTrapFarFromObstacles(threshold = 260) {
      for (const o of obstacles) {
        const dist = canvas.width - o.x;
        if (dist <= threshold) return false;
      }
      return true;
    }

    // -------------------------------------------------------
    // Shop reflection UI
    // -------------------------------------------------------
    function updateShopReflection() {
      timeLevelEl.textContent = timeLevel;
      hackerLevelEl.textContent = hackerLevel;
      jumpLevelEl.textContent = jumpLevel;
      magnetLevelEl.textContent = magnetLevel;
      curseBenderLevelEl.textContent = curseBenderLevel;

      timeEffectEl.textContent = TIME_UPGRADE.effect(timeLevel);
      hackerEffectEl.textContent = HACKER_UPGRADE.effect(hackerLevel);
      jumpEffectEl.textContent = JUMP_UPGRADE.effect(jumpLevel);
      magnetEffectEl.textContent = MAGNET_UPGRADE.effect(magnetLevel);
      curseBenderEffectEl.textContent = CURSE_BENDER_UPGRADE.effect(curseBenderLevel);

      skinsListEl.innerHTML = '';
      SKINS.forEach(skin => {
        const owned = !!ownedSkins[skin.id];
        const equipped = equippedSkin === skin.id;
        const row = document.createElement('div');
        row.className = 'flex items-center justify-between gap-3';
        const previewId = 'skin-' + skin.id;
        row.innerHTML = `
          <div class="flex items-center gap-3">
            <canvas id="${previewId}" width="60" height="80" class="skin-preview"></canvas>
            <div>
              <div class="font-bold">${skin.name}</div>
              <div class="hint">Owned: <span class="${owned?'text-green-300':'text-red-300'}">${owned?'Yes':'No'}</span> | Equipped: <span class="${equipped?'text-green-300':'text-red-300'}">${equipped?'Yes':'No'}</span></div>
            </div>
          </div>
          <div class="hint">Cost: ${skin.cost} coins</div>
        `;
        skinsListEl.appendChild(row);
        renderSkinPreview(previewId, skin.id);
      });

      updateHackerButtonUI();
      updateTimeButtonUI();
      updateGoldenHackerButtonUI();
    }

    function renderSkinPreview(canvasId, skinId) {
      const c = document.getElementById(canvasId);
      if (!c) return;
      const pctx = c.getContext('2d');
      pctx.clearRect(0,0,c.width,c.height);
      const x = 18, y = 20, w = 24, h = 36;
      const drawLines = (color) => drawStickmanLines(pctx, x, y, w, h, color, 3);

      switch (skinId) {
        case 'ninja': {
          drawLines('#000000');
          const cx = x + w/2, cy = y + 5, r = 6;
          pctx.strokeStyle = NINJA_BAND_RED; pctx.lineWidth = 2;
          pctx.beginPath(); pctx.arc(cx, cy, r, Math.PI*0.15, Math.PI*1.85); pctx.stroke();
          pctx.beginPath(); pctx.arc(cx, cy, r+2, Math.PI*0.15, Math.PI*1.85); pctx.stroke();
          pctx.fillStyle = NINJA_BAND_RED; pctx.beginPath(); pctx.arc(x + w/2 - r - 2, cy, 2, 0, Math.PI*2); pctx.fill();
          pctx.strokeStyle = NINJA_BAND_RED; pctx.beginPath();
          pctx.moveTo(x + w/2 - r - 2, cy);
          pctx.quadraticCurveTo(x + w/2 - r - 12, cy - 6, x + w/2 - r - 18, cy - 2);
          pctx.quadraticCurveTo(x + w/2 - r - 10, cy + 6, x + w/2 - r - 18, cy + 10);
          pctx.stroke();
          break;
        }
        case 'alien': drawLines(ALIEN_GREEN); break;
        case 'robot': {
          drawLines(ROBOT_GRAY);
          const hx = x + w/2, hy = y + 5;
          pctx.fillStyle = ROBOT_EYE_CYAN;
          pctx.beginPath(); pctx.ellipse(hx - 3, hy, 2, 3, 0, 0, Math.PI*2); pctx.fill();
          pctx.beginPath(); pctx.ellipse(hx + 3, hy, 2, 3, 0, 0, Math.PI*2); pctx.fill();
          break;
        }
        case 'pirate': {
          drawLines(PIRATE_BLACK);
          const px = x + w/2, py = y - 2;
          pctx.fillStyle = PIRATE_BLACK;
          pctx.fillRect(px - 14, py, 28, 4);
          pctx.beginPath();
          pctx.moveTo(px - 10, py);
          pctx.quadraticCurveTo(px, py - 10, px + 10, py);
          pctx.lineTo(px + 10, py + 8);
          pctx.lineTo(px - 10, py + 8);
          pctx.closePath(); pctx.fill();
          const bodyTop = y + 12, bodyBottom = y + h - 10;
          pctx.strokeStyle = PIRATE_STRIPE_RED; pctx.lineWidth = 3;
          pctx.beginPath(); pctx.moveTo(x + w/2 - 5, bodyTop); pctx.lineTo(x + w/2 - 5, bodyBottom); pctx.stroke();
          pctx.strokeStyle = PIRATE_STRIPE_BROWN;
          pctx.beginPath(); pctx.moveTo(x + w/2 + 5, bodyTop); pctx.lineTo(x + w/2 + 5, bodyBottom); pctx.stroke();
          break;
        }
        case 'santa': {
          drawLines(SANTA_RED);
          pctx.strokeStyle = SANTA_WHITE; pctx.lineWidth = 3;
          pctx.beginPath(); pctx.moveTo(x + 4, y + (h/2 - 5)); pctx.lineTo(x + 8, y + (h/2 - 5)); pctx.stroke();
          pctx.beginPath(); pctx.moveTo(x + w - 8, y + (h/2 - 5)); pctx.lineTo(x + w - 4, y + (h/2 - 5)); pctx.stroke();
          pctx.beginPath(); pctx.moveTo(x + 6, y + h - 2); pctx.lineTo(x + 10, y + h - 2); pctx.stroke();
          pctx.beginPath(); pctx.moveTo(x + w - 10, y + h - 2); pctx.lineTo(x + w - 6, y + h - 2); pctx.stroke();
          const shx = x + w/2, shy = y - 2;
          pctx.fillStyle = SANTA_RED;
          pctx.beginPath();
          pctx.moveTo(shx - 10, shy);
          pctx.quadraticCurveTo(shx + 2, shy - 12, shx + 12, shy - 4);
          pctx.lineTo(shx + 12, shy);
          pctx.closePath(); pctx.fill();
          pctx.fillStyle = SANTA_WHITE; pctx.fillRect(shx - 12, shy, 24, 3);
          pctx.beginPath(); pctx.arc(shx + 12, shy - 4, 3, 0, Math.PI*2); pctx.fill();
          break;
        }
        case 'golden': drawLines(GOLDEN_LINE); break;
        default: drawLines(DEFAULT_GOLD);
      }
      pctx.strokeStyle = '#1f2937';
      pctx.lineWidth = 1;
      const baseY = y + h + 4;
      pctx.beginPath(); pctx.moveTo(8, baseY); pctx.lineTo(c.width - 8, baseY); pctx.stroke();
    }

    // -------------------------------------------------------
    // Game lifecycle
    // -------------------------------------------------------
    let animationId = null;
    let lastTime = 0;

    function startGame() {
      stopGame();
      score = 0;
      obstacles = [];
      holes = [];
      traps = [];
      coins = [];
      bestLevel = Math.max(bestLevel || 0, Math.floor(highScore || 0));
      isGameOver = false;
      isPausedForCurse = false;
      isFalling = false;
      obstacleSpawnTimer = 0;
      coinSpawnTimer = 0;
      currentSpeed = BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0);

      jumpCount = 0;
      isHackerAbilityReady = true;
      hackerCooldownRemaining = 0;
      isTimeAbilityReady = true;
      timeCooldownRemaining = 0;
      timeEffectRemaining = 0;
      if (goldenHackerUnlocked) { goldenHackerReady = true; goldenHackerCooldownRemaining = 0; }

      activeCurses = activeCurses.filter(c => !c.expiresAt);
      curseFogActive = false;
      curseCoinTaxActive = false;
      curseSlipActive = false; slipTimer = 0;
      curseDoubleGravityActive = false;
      curseSlowRecoverActive = false;
      curseMagnetMalfunctionActive = false;
      curseObstacleFrenzyActive = false;
      curseTrapStormActive = false;
      curseBlindBarActive = false;
      coinDrainTimer = 0;

      player = new Player();
      player.setSkin(equippedSkin);
      resizeCanvas();
      canvas.style.borderColor = '#e94560';
      lastTime = 0;
      gameOverBackdrop.style.display = 'none';
      animationId = requestAnimationFrame(loop);
    }

    function stopGame() {
      if (animationId) cancelAnimationFrame(animationId);
      animationId = null;
      saveBackToHub();
    }

    function loop(currentTime) {
      if (!lastTime) lastTime = currentTime;
      const delta = Math.min(currentTime - lastTime, 100);
      lastTime = currentTime;

      if (isGameOver) { stopGame(); return; }
      if (isPausedForCurse) { animationId = requestAnimationFrame(loop); return; }

      update(delta);
      draw();
      animationId = requestAnimationFrame(loop);
    }

    function update(delta) {
      score += delta / 16;
      const uiScore = Math.floor(score / 10);
      uiScoreEl.textContent = uiScore;

      bestLevel = Math.max(bestLevel, uiScore);

      const nextThreshold = Math.floor(uiScore / 100) * 100;
      if (uiScore > 0 && uiScore % 100 === 0 && nextThreshold !== lastCurseThresholdAwarded && !isPausedForCurse) {
        showCurseModal();
        return;
      }

      const speedFactor = Math.min(uiScore / MAX_SCORE_FOR_SPEED, 1);
      const baseSpeedOffset = (curseSpeedSurgeActive ? 2 : 0);
      const calculatedSpeed = (BASE_GAME_SPEED + baseSpeedOffset) + (MAX_GAME_SPEED_INCREASE * speedFactor);

      const effectiveSpeed = (timeEffectRemaining <= 0 ? calculatedSpeed : currentSpeed) * (curseSlipActive ? 1.5 : 1.0);
      if (timeEffectRemaining <= 0) { currentSpeed = calculatedSpeed; canvas.style.borderColor = '#e94560'; }

      if (hackerCooldownRemaining > 0) {
        hackerCooldownRemaining -= delta;
        if (hackerCooldownRemaining <= 0) { hackerCooldownRemaining = 0; isHackerAbilityReady = true; }
        updateHackerButtonUI();
      }
      if (timeCooldownRemaining > 0) {
        timeCooldownRemaining -= delta;
        if (timeCooldownRemaining <= 0) { timeCooldownRemaining = 0; isTimeAbilityReady = true; }
        updateTimeButtonUI();
      }
      if (timeEffectRemaining > 0) {
        timeEffectRemaining -= delta;
        if (timeEffectRemaining <= 0) { timeEffectRemaining = 0; currentSpeed = calculatedSpeed; }
        updateTimeButtonUI();
      }
      if (goldenHackerCooldownRemaining > 0) {
        goldenHackerCooldownRemaining -= delta;
        if (goldenHackerCooldownRemaining <= 0) { goldenHackerCooldownRemaining = 0; goldenHackerReady = true; }
        updateGoldenHackerButtonUI();
      }

      updateCurses(delta);

      const groundY = canvas.height - GROUND_HEIGHT - player.height;
      if (!isFalling) {
        player.vy += getDynamicGravity();
        player.y += player.vy;
        if (player.y >= groundY) {
          let inHole = false;
          for (const hole of holes) {
            if (player.x + player.width > hole.x && player.x < hole.x + hole.width) { inHole = true; break; }
          }
          if (inHole) { isFalling = true; player.vy = 0; }
          else { player.y = groundY; player.vy = 0; jumpCount = 0; }
        }
      } else {
        player.vy += getDynamicGravity(3);
        player.y += player.vy;
        if (player.y > canvas.height + 50) { endGame('fall out of bounds'); return; }
      }

      const initialRate = 110;
      const minRate = MIN_OBSTACLE_RATE;
      const difficultyFactor = Math.min(uiScore / MAX_SCORE_FOR_OBSTACLE_DENSITY, 1);
      const rateReduction = (initialRate - minRate) * difficultyFactor;
      obstacleSpawnRate = initialRate - rateReduction;
      if (curseObstacleFrenzyActive) obstacleSpawnRate = Math.max(minRate, obstacleSpawnRate / 2);

      obstacleSpawnTimer++;
      if (obstacleSpawnTimer >= obstacleSpawnRate && canSpawnObstacle()) {
        if (Math.random() < 0.15) {
          holes.push(new Hole());
        } else {
          const spawnAir = Math.random() < 0.3;
          if (spawnAir && canSpawnAirObstacleFarFromGround(220)) {
            obstacles.push(new Obstacle('air'));
          } else {
            obstacles.push(new Obstacle('ground'));
          }
        }
        obstacleSpawnTimer = 0;
      }

      const trapProb = TRAP_SPAWN_PROBABILITY * (curseTrapStormActive ? 3 : 1);
      if (uiScore >= TRAP_MIN_UI_SCORE && Math.random() < trapProb && canSpawnTrapFarFromObstacles(260)) {
        traps.push(new Trap());
      }

      coinSpawnTimer++;
      if (coinSpawnTimer >= COIN_SPAWN_RATE) {
        if (Math.random() < 0.6) coins.push(new Coin());
        coinSpawnTimer = 0;
      }

      if (magnetLevel > 0 && coins.length > 0) {
        const magnetRadius = MAGNET_UPGRADE.radii[magnetLevel - 1];
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;

        for (let i = coins.length - 1; i >= 0; i--) {
          const coin = coins[i];
          const cx = coin.x + coin.size / 2;
          const cy = coin.y + coin.size / 2;
          const dx = px - cx;
          const dy = py - cy;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const isOverheadX = (coin.x + coin.size > player.x) && (coin.x < player.x + player.width);
          const isHigherY = coin.y < player.y + player.height / 2;

          const shouldZip = magnetLevel === 2 ? (distance <= magnetRadius)
            : (distance <= magnetRadius && isOverheadX && isHigherY);

          if (shouldZip) {
            if (!curseMagnetMalfunctionActive) {
              coin.x += dx;
              coin.y += dy;
              let value = coin.baseValue;
              if (magnetLevel === 1) value = MAGNET_UPGRADE.values[0];
              else if (magnetLevel === 2) value = MAGNET_UPGRADE.values[1];
              if (curseCoinTaxActive) value = Math.max(0, Math.floor(value * 0.5));
              playerCoins += value;
              uiCoinsEl.textContent = playerCoins;
              coins.splice(i, 1);
              saveBackToHub();
            } else {
              coin.x -= dx * 0.6;
              coin.y -= dy * 0.6;
            }
          }
        }
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.update(effectiveSpeed);
        if (obs.x + obs.width < 0) { obstacles.splice(i, 1); continue; }
        if (obs.isBypassed) continue;
        if (player.x < obs.x + obs.width &&
            player.x + player.width > obs.x &&
            player.y < obs.y + obs.height &&
            player.y + player.height > obs.y) {
          endGame('obstacle collision'); return;
        }
      }

      for (let i = holes.length - 1; i >= 0; i--) {
        const hole = holes[i];
        hole.update(effectiveSpeed);
        if (hole.x + hole.width < 0) holes.splice(i, 1);
      }

      for (let i = traps.length - 1; i >= 0; i--) {
        const trap = traps[i];
        trap.update(effectiveSpeed);
        if (trap.x + trap.width < 0) { traps.splice(i, 1); continue; }
        if (!trap.isTriggered &&
            player.y + player.height === trap.y &&
            player.x + player.width > trap.x &&
            player.x < trap.x + trap.width) {
          trap.isTriggered = true;
          endGame('trap collision'); return;
        }
      }

      for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        coin.update(effectiveSpeed);
        if (player.x < coin.x + coin.size &&
            player.x + player.width > coin.x &&
            player.y < coin.y + coin.size &&
            player.y + player.height > coin.y) {
          let value = coin.baseValue;
          if (magnetLevel === 1) value = MAGNET_UPGRADE.values[0];
          else if (magnetLevel === 2) value = MAGNET_UPGRADE.values[1];
          if (curseCoinTaxActive) value = Math.max(0, Math.floor(value * 0.5));
          playerCoins += value;
          uiCoinsEl.textContent = playerCoins;
          coins.splice(i, 1);
          saveBackToHub();
          continue;
        }
        if (coin.x + coin.size < 0) coins.splice(i, 1);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2d3748';
      ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

      if (curseFogActive) {
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      holes.forEach(h => h.draw());
      traps.forEach(t => t.draw());
      obstacles.forEach(o => o.draw());
      coins.forEach(c => c.draw());
      if (player) player.draw();

      if (curseBlindBarActive) {
        ctx.fillStyle = '#000';
        ctx.fillRect(blindBar.x, 0, blindBar.w, canvas.height);
      }
    }

    function endGame(reason='unknown') {
      isGameOver = true;
      curseBackdrop.style.display = 'none';
      const finalScore = Math.floor(score/10);
      finalScoreEl.textContent = finalScore;

      if (finalScore > highScore) { highScore = finalScore; }
      bestLevel = Math.max(bestLevel, finalScore);
      saveBackToHub();
      console.log('Game Over:', reason, 'Score:', finalScore);

      uiHighEl.textContent = highScore;
      gameOverBackdrop.style.display = 'flex';
    }

    // -------------------------------------------------------
    // Helpers
    // -------------------------------------------------------
    function getDynamicGravity(multiplier = 1) {
      const maxSpeed = BASE_GAME_SPEED + MAX_GAME_SPEED_INCREASE;
      let baseSpeedAdj = BASE_GAME_SPEED + (curseSpeedSurgeActive ? 2 : 0);
      const speedFactor = Math.min((currentSpeed - baseSpeedAdj) / ((maxSpeed - baseSpeedAdj) * GRAVITY_SLOW_FACTOR), 1);
      const gravityBase = BASE_GRAVITY_START + cursePermanentGravityBoost;
      let gravity = gravityBase + (MAX_GRAVITY - gravityBase) * Math.max(0, speedFactor);
      if (curseDoubleGravityActive) gravity *= 2;
      return gravity * multiplier;
    }

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      if (player) {
        const groundY = canvas.height - GROUND_HEIGHT - player.height;
        if (player.y > groundY && !isFalling) player.y = groundY;
      }
      draw();
    }

    function loadFromHub() {
      currentUsername = hubGetCurrentUser();
      if (!currentUsername) {
        accountUsernameEl.textContent = 'Not logged in';
        accountCoinsEl.textContent = '0';
        accountHighEl.textContent = '0';
        uiCoinsEl.textContent = '0';
        uiHighEl.textContent = '0';
        return false;
      }
      userData = hubGetUserData(currentUsername);
      if (!userData) {
        accountUsernameEl.textContent = currentUsername + ' (no data)';
        return false;
      }
      playerCoins = userData.coins || 0;
      highScore = userData.highScoreStickman || 0;
      bestLevel = userData.bestLevelStickman || 0;

      timeLevel = userData.upgrades?.time || 0;
      hackerLevel = userData.upgrades?.hacker || 0;
      jumpLevel = userData.upgrades?.jump || 0;
      magnetLevel = userData.upgrades?.magnet || 0;
      curseBenderLevel = userData.upgrades?.curseBender || 0;

      ownedSkins = { default: true };
      (userData.skins?.owned || []).forEach(id => ownedSkins[id] = true);
      equippedSkin = userData.skins?.equipped || 'default';
      goldenHackerUnlocked = !!userData.goldenHackerUnlocked || ownedSkins.golden;

      accountUsernameEl.textContent = currentUsername;
      accountCoinsEl.textContent = playerCoins;
      accountHighEl.textContent = highScore;
      uiCoinsEl.textContent = playerCoins;
      uiHighEl.textContent = highScore;
      uiBestEl.textContent = bestLevel;

      updateShopReflection();
      return true;
    }

    function saveBackToHub() {
      if (!currentUsername) return;
      const existing = hubGetUserData(currentUsername) || {};
      const ownedList = Object.keys(ownedSkins).filter(k => ownedSkins[k]);
      const data = {
        password: existing.password || '',
        coins: playerCoins,
        upgrades: {
          time: timeLevel,
          hacker: hackerLevel,
          jump: jumpLevel,
          magnet: magnetLevel,
          curseBender: curseBenderLevel
        },
        skins: { owned: ownedList, equipped: equippedSkin },
        goldenHackerUnlocked: goldenHackerUnlocked || !!existing.goldenHackerUnlocked,
        highScoreStickman: Math.max(existing.highScoreStickman || 0, highScore),
        bestLevelStickman: Math.max(existing.bestLevelStickman || 0, bestLevel),

        // future games can append their own keys untouched here
        highScoreNewGame: existing.highScoreNewGame || 0,
        bestLevelNewGame: existing.bestLevelNewGame || 0,
        locked: existing.locked || false
      };
      hubSaveUserData(currentUsername, data);

      accountCoinsEl.textContent = playerCoins;
      accountHighEl.textContent = data.highScoreStickman;
      uiHighEl.textContent = data.highScoreStickman;
      uiBestEl.textContent = data.bestLevelStickman;
    }

    // -------------------------------------------------------
    // Boot
    // -------------------------------------------------------
    window.addEventListener('resize', () => { resizeCanvas(); });
    window.addEventListener('mouseup', () => player?.crouch(false));
    window.addEventListener('touchend', () => player?.crouch(false));

    (function init() {
      bindInput();
      const ok = loadFromHub();
      resizeCanvas();
      if (!ok) {
        alert('Please login in the Hub first.');
      }
      startGame();
    })();
  </script>
</body>
</html>
