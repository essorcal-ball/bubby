<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Arcade Hero</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, system-ui, sans-serif; background:#1a1a2e; }
    .screen { display:none; height:100vh; width:100vw; box-sizing:border-box; }
    #gameCanvas { background:#4a5568; border:4px solid #e94560; border-radius:12px; }
    .account-bar { position:fixed; top:0; right:0; background:#16213e; padding:8px 12px; border-bottom-left-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,0.4); z-index:50; }
    .shop-card { background:#16213e; border-radius:12px; padding:1rem; margin-bottom:1rem; }
    .shop-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(260px,1fr)); gap:14px; width:100%; max-width:1100px; }
    .overlay { transition: height 0.1s linear; }
    .badge { background:#203463; border-radius:999px; padding:4px 10px; font-size:12px; }
    .main-button { transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.35); }
    .main-button:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,0.45); }
  </style>
</head>
<body class="text-white">

  <!-- Account Bar -->
  <div class="account-bar flex items-center gap-3">
    <span class="text-yellow-300">Logged in as: <span id="current-username">Guest</span></span>
    <button onclick="logoutAccount()" class="bg-red-600 px-3 py-1 rounded">Logout</button>
  </div>

  <!-- LOGIN -->
  <div id="login-screen" class="screen flex flex-col items-center justify-center p-6">
    <h1 class="text-5xl font-bold text-[#e94560] mb-8">Welcome to Arcade Hero</h1>
    <div class="w-full max-w-sm space-y-4">
      <input id="username-input" type="text" placeholder="Username" class="w-full p-3 rounded text-black"/>
      <input id="password-input" type="password" placeholder="Password" class="w-full p-3 rounded text-black"/>
      <input id="confirm-password-input" type="password" placeholder="Confirm Password" class="w-full p-3 rounded text-black"/>
      <button onclick="createAccount()" class="bg-green-600 text-white font-bold py-2 px-4 rounded w-full">Create Account</button>
      <button onclick="loginAccount()" class="bg-blue-600 text-white font-bold py-2 px-4 rounded w-full">Login</button>
    </div>
  </div>

  <!-- MENU -->
  <div id="menu-screen" class="screen flex flex-col items-center justify-center p-6">
    <h1 class="text-6xl font-bold text-[#e94560] mb-10">ARCADE HERO</h1>
    <button onclick="goToScreen('game')" class="bg-[#16213e] text-3xl font-bold py-4 rounded-xl mb-4">PLAY GAME</button>
    <button onclick="goToScreen('shop')" class="bg-[#16213e] text-3xl font-bold py-4 rounded-xl">SHOP</button>
  </div>

  <!-- GAME -->
  <div id="game-screen" class="screen flex flex-col items-center justify-start py-8 px-4">
    <div class="flex justify-between w-full max-w-4xl mb-4">
      <span>Score: <span id="current-score">0</span></span>
      <span>High Score: <span id="high-score">0</span></span>
      <span>üí∞ Coins: <span id="coin-count">0</span></span>
      <span>Equipped: <span id="equipped-skin-display">default</span></span>
    </div>
    <canvas id="gameCanvas" class="w-full max-w-4xl h-96 md:h-[500px]"></canvas>
    <div class="mt-6 flex flex-wrap justify-center gap-4">
      <button onclick="player?.jump()" id="jump-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg main-button">JUMP</button>
      <button id="crouch-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg main-button">CROUCH (ArrowDown/S)</button>

      <button id="hacker-button" onclick="activateHackerAbility()" class="main-button bg-purple-600 text-white font-bold py-3 px-8 rounded-lg relative overflow-hidden disabled:bg-gray-700" disabled>
        <div id="hacker-cooldown-overlay" class="absolute inset-0 bg-red-600 opacity-80 overlay" style="height:100%;"></div>
        <span id="hacker-cooldown-text" class="relative z-20">BUY IN SHOP</span>
      </button>

      <button id="time-button" onclick="activateTimeAbility()" class="main-button bg-blue-600 text-white font-bold py-3 px-8 rounded-lg relative overflow-hidden disabled:bg-gray-700" disabled>
        <div id="time-cooldown-overlay" class="absolute inset-0 bg-red-600 opacity-80 overlay" style="height:100%;"></div>
        <span id="time-cooldown-text" class="relative z-20">BUY IN SHOP</span>
      </button>

      <button onclick="startGame()" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-8 rounded-lg main-button">Restart</button>
      <button onclick="goToScreen('menu')" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-8 rounded-lg main-button">‚Üê Quit</button>
    </div>

    <div id="game-over-modal" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden">
      <div class="bg-red-800 p-8 rounded-xl shadow-2xl text-center border-4 border-red-500">
        <h3 class="text-5xl font-extrabold mb-4 text-white">GAME OVER!</h3>
        <p class="text-2xl mb-6">Your Score: <span id="final-score" class="font-bold">0</span></p>
        <button onclick="startGame()" class="main-button bg-[#e94560] text-2xl font-bold py-3 px-6 rounded-lg hover:bg-[#d53e54]">Try Again</button>
      </div>
    </div>
  </div>

  <!-- SHOP -->
  <div id="shop-screen" class="screen flex flex-col items-center justify-start py-10 px-4">
    <h2 class="text-5xl font-bold text-[#e94560] mb-4">The Item Shop</h2>
    <p class="mb-6">Coins: <span id="shop-coin-count" class="font-bold text-yellow-300">0</span> ‚Ä¢ High Score: <span id="shop-high-score" class="font-bold text-yellow-300">0</span></p>

    <!-- Upgrades -->
    <div class="shop-grid mb-8">
      <div class="shop-card">
        <h3 class="text-2xl font-bold text-blue-300 mb-2">Time Warp (Active)</h3>
        <p>Level: <span id="time-level">0</span></p>
        <p id="time-effect" class="text-sm text-gray-300">Effect: Not purchased.</p>
        <p id="time-req" class="text-sm text-gray-300"></p>
        <p id="time-cost" class="mt-1 font-bold text-yellow-300">Cost: --</p>
        <button onclick="buyUpgrade('time')" id="buy-time-button" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2">Buy</button>
      </div>
      <div class="shop-card">
        <h3 class="text-2xl font-bold text-purple-300 mb-2">Hacker (Active)</h3>
        <p>Level: <span id="hacker-level">0</span></p>
        <p id="hacker-effect" class="text-sm text-gray-300">Effect: Not purchased.</p>
        <p id="hacker-req" class="text-sm text-gray-300"></p>
        <p id="hacker-cost" class="mt-1 font-bold text-yellow-300">Cost: --</p>
        <button onclick="buyUpgrade('hacker')" id="buy-hacker-button" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2">Buy</button>
      </div>
      <div class="shop-card">
        <h3 class="text-2xl font-bold text-green-300 mb-2">Jump (Passive)</h3>
        <p>Level: <span id="jump-level">0</span></p>
        <p id="jump-effect" class="text-sm text-gray-300">Effect: Single jump.</p>
        <p id="jump-req" class="text-sm text-gray-300"></p>
        <p id="jump-cost" class="mt-1 font-bold text-yellow-300">Cost: --</p>
        <button onclick="buyUpgrade('jump')" id="buy-jump-button" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2">Buy</button>
      </div>
      <div class="shop-card">
        <h3 class="text-2xl font-bold text-yellow-300 mb-2">Money Magnet (Passive)</h3>
        <p>Level: <span id="magnet-level">0</span></p>
        <p id="magnet-effect" class="text-sm text-gray-300">Effect: No magnet.</p>
        <p id="magnet-req" class="text-sm text-gray-300"></p>
        <p id="magnet-cost" class="mt-1 font-bold text-yellow-300">Cost: --</p>
        <button onclick="buyUpgrade('magnet')" id="buy-magnet-button" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2">Buy</button>
      </div>
    </div>

    <!-- Skins -->
    <p class="text-sm mb-4">Equipped: <span id="equipped-skin" class="font-bold">default</span></p>
    <div class="shop-grid">
      <div class="shop-card">
        <canvas id="preview-default" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Default</p>
        <div class="flex gap-2 mt-2">
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('default')">Equip</button>
          <span class="badge">Owned</span>
        </div>
      </div>
      <div class="shop-card">
        <canvas id="preview-santa" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Santa ‚Ä¢ Cost: 5</p>
        <p>Owned: <span id="santa-owned">No</span></p>
        <div class="flex gap-2 mt-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded main-button" onclick="buySkin('santa')">Buy</button>
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('santa')">Equip</button>
        </div>
      </div>
      <div class="shop-card">
        <canvas id="preview-ninja" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Ninja ‚Ä¢ Cost: 10</p>
        <p>Owned: <span id="ninja-owned">No</span></p>
        <div class="flex gap-2 mt-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded main-button" onclick="buySkin('ninja')">Buy</button>
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('ninja')">Equip</button>
        </div>
      </div>
      <div class="shop-card">
        <canvas id="preview-robot" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Robot ‚Ä¢ Cost: 12</p>
        <p>Owned: <span id="robot-owned">No</span></p>
        <div class="flex gap-2 mt-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded main-button" onclick="buySkin('robot')">Buy</button>
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('robot')">Equip</button>
        </div>
      </div>
      <div class="shop-card">
        <canvas id="preview-pirate" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Pirate ‚Ä¢ Cost: 8</p>
        <p>Owned: <span id="pirate-owned">No</span></p>
        <div class="flex gap-2 mt-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded main-button" onclick="buySkin('pirate')">Buy</button>
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('pirate')">Equip</button>
        </div>
      </div>
      <div class="shop-card">
        <canvas id="preview-rainbow" width="100" height="100"></canvas>
        <p class="mt-2 font-semibold">Rainbow ‚Ä¢ Cost: 15</p>
        <p>Owned: <span id="rainbow-owned">No</span></p>
        <div class="flex gap-2 mt-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded main-button" onclick="buySkin('rainbow')">Buy</button>
          <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded main-button" onclick="equipSkin('rainbow')">Equip</button>
        </div>
      </div>
    </div>

    <button onclick="goToScreen('menu')" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg main-button mt-8">‚Üê Back to Menu</button>
  </div>

<script>
  // =========================
  // Account system (localStorage)
  // =========================
  let currentUser = null;
  const currentUsernameElement = document.getElementById('current-username');

  function getUserData(username) {
    const data = localStorage.getItem(`stickmanUser_${username}`);
    return data ? JSON.parse(data) : null;
  }
  function saveUserData(username, data) {
    localStorage.setItem(`stickmanUser_${username}`, JSON.stringify(data));
  }
  function togglePassword(fieldId) {
    const input = document.getElementById(fieldId);
    const btn = input.nextElementSibling;
    if (input.type === 'password') { input.type = 'text'; btn.textContent = 'Hide'; }
    else { input.type = 'password'; btn.textContent = 'Show'; }
  }
  function createAccount() {
    const u = document.getElementById('username-input').value.trim();
    const p = document.getElementById('password-input').value.trim();
    const c = document.getElementById('confirm-password-input').value.trim();
    if (!u || !p || !c) return alert('Please fill in all fields.');
    if (p !== c) return alert('Passwords do not match.');
    if (getUserData(u)) return alert('Account already exists. Please login.');
    const newUser = {
      password: p,
      coins: 0,
      highScore: 0,
      upgrades: { time:0, hacker:0, jump:0, magnet:0 },
      skins: { owned:['default'], equipped:'default' }
    };
    saveUserData(u, newUser);
    alert('Account created! Please login.');
  }
  function loginAccount() {
    const u = document.getElementById('username-input').value.trim();
    const p = document.getElementById('password-input').value.trim();
    const data = getUserData(u);
    if (!data) return alert('No account found. Please create one.');
    if (data.password !== p) return alert('Incorrect password.');
    currentUser = u;
    loadUserData(data);
    updateUserStatus();
    goToScreen('menu');
  }
  function logoutAccount() {
    if (!currentUser) return alert('No user is currently logged in.');
    persistUserData();
    alert(`Logged out from ${currentUser}.`);
    currentUser = null;

    // Reset runtime state
    playerCoins = 0; highScore = 0;
    timeLevel = 0; hackerLevel = 0; jumpLevel = 0; magnetLevel = 0;
    ownedSkins = { default:true, santa:false, ninja:false, robot:false, pirate:false, rainbow:false };
    equippedSkin = 'default';
    coinCountElement.textContent = playerCoins;
    highScoreElement.textContent = highScore;
    document.getElementById('equipped-skin-display').textContent = equippedSkin;
    updateUserStatus();
    goToScreen('login');
  }
  function loadUserData(data) {
    playerCoins = data.coins || 0;
    highScore = data.highScore || 0;
    timeLevel = data.upgrades?.time || 0;
    hackerLevel = data.upgrades?.hacker || 0;
    jumpLevel = data.upgrades?.jump || 0;
    magnetLevel = data.upgrades?.magnet || 0;

    ownedSkins = { default:true, santa:false, ninja:false, robot:false, pirate:false, rainbow:false };
    (data.skins?.owned || ['default']).forEach(k => { if (ownedSkins.hasOwnProperty(k)) ownedSkins[k] = true; });
    equippedSkin = data.skins?.equipped || 'default';

    coinCountElement.textContent = playerCoins;
    highScoreElement.textContent = highScore;
    document.getElementById('equipped-skin-display').textContent = equippedSkin;
    updateShopUI();
    updateHackerButtonUI();
    updateTimeButtonUI();
  }
  function persistUserData() {
    if (!currentUser) return;
    const ownedList = Object.keys(ownedSkins).filter(k => ownedSkins[k]);
    const data = {
      password: getUserData(currentUser)?.password || '',
      coins: playerCoins,
      highScore: highScore,
      upgrades: { time: timeLevel, hacker: hackerLevel, jump: jumpLevel, magnet: magnetLevel },
      skins: { owned: ownedList, equipped: equippedSkin }
    };
    saveUserData(currentUser, data);
  }
  function updateUserStatus() { currentUsernameElement.textContent = currentUser ? currentUser : 'Guest'; }

  // =========================
  // Navigation
  // =========================
  const screens = {
    login: document.getElementById('login-screen'),
    menu: document.getElementById('menu-screen'),
    game: document.getElementById('game-screen'),
    shop: document.getElementById('shop-screen')
  };
  let currentScreen = 'login';
  function goToScreen(target) {
    if ((target === 'game' || target === 'shop') && !currentUser) { alert('You must log in first!'); target = 'login'; }
    Object.values(screens).forEach(s => s.style.display = 'none');
    screens[target].style.display = 'flex';
    currentScreen = target;
    if (target === 'game') { resizeCanvas(); startGame(); } // auto-start the game
    if (target === 'shop') { updateShopUI(); renderPreviews(); }
  }
  window.onload = () => { goToScreen('login'); updateUserStatus(); renderPreviews(); };

  // =========================
  // Game constants and state
  // =========================
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const GROUND_HEIGHT = 50;
  const PLAYER_SIZE = 18; // small stickman
  const START_SPAWN_SCORE = 20; // delay spawns to avoid initial lag

  let player;
  let obstacles = [];
  let holes = [];
  let traps = [];
  let coins = [];
  let score = 0;
  let currentSpeed = 4.0;
  const maxSpeedIncrease = 6.0;
  const maxScoreForSpeed = 400;
  let obstacleSpawnRate = 100;
  const minObstacleRate = 20;
  let obstacleSpawnTimer = 0;
  let coinSpawnTimer = 0;
  const COIN_SPAWN_RATE = 350;
  let isGameOver = false;
  let lastTime = 0;
  let animationFrameId = null;

  // UI refs
  const scoreElement = document.getElementById('current-score');
  const highScoreElement = document.getElementById('high-score');
  const finalScoreElement = document.getElementById('final-score');
  const coinCountElement = document.getElementById('coin-count');
  const shopCoinCountElement = document.getElementById('shop-coin-count');
  const shopHighScoreElement = document.getElementById('shop-high-score');
  const gameOverModal = document.getElementById('game-over-modal');
  const equippedDisplay = document.getElementById('equipped-skin-display');

  // Buttons
  const hackerButton = document.getElementById('hacker-button');
  const hackerCooldownOverlay = document.getElementById('hacker-cooldown-overlay');
  const hackerCooldownText = document.getElementById('hacker-cooldown-text');
  const timeButton = document.getElementById('time-button');
  const timeCooldownOverlay = document.getElementById('time-cooldown-overlay');
  const timeCooldownText = document.getElementById('time-cooldown-text');

  // Progress
  let highScore = 0;
  let playerCoins = 0;

  // Upgrades (persisted)
  let timeLevel = 0;
  let hackerLevel = 0;
  let jumpLevel = 0;
  let magnetLevel = 0;

  // Active abilities runtime
  let isHackerAbilityReady = true;
  let hackerCooldownRemaining = 0;
  let isTimeAbilityReady = true;
  let timeCooldownRemaining = 0;
  let timeEffectRemaining = 0;

  // Skins
  let equippedSkin = 'default';
  let ownedSkins = { default:true, santa:false, ninja:false, robot:false, pirate:false, rainbow:false };
  const skinCosts = { santa:5, ninja:10, robot:12, pirate:8, rainbow:15 };

  // =========================
  // Upgrades setup
  // =========================
  const TIME_UPGRADE = {
    costs: [12, 20, 35],
    cooldowns: [30000, 20000, 35000],
    highScoreRequirement: [200, 300, 0], // Lv1 requires 200
    effectDuration: [4000, 5000, 6000],
    slowdownFactor: [0.7, 0.5, 'BASE'],
    maxLevel: 3,
    effect: (lvl) => {
      if (lvl === 0) return 'Not purchased.';
      const cd = TIME_UPGRADE.cooldowns[lvl-1]/1000;
      if (lvl === 3) return `Cooldown ${cd}s. Reset speed to base for ${TIME_UPGRADE.effectDuration[lvl-1]/1000}s.`;
      const factor = TIME_UPGRADE.slowdownFactor[lvl-1];
      return `Cooldown ${cd}s. Slow to ${Math.floor(factor*100)}% for ${TIME_UPGRADE.effectDuration[lvl-1]/1000}s.`;
    }
  };
  const HACKER_UPGRADE = {
    costs: [10, 25, 40],
    cooldowns: [9000, 13000, 16000],
    highScoreRequirement: [250, 550, 800], // Lv1 requires 250
    maxLevel: 3,
    effect: (lvl) => {
      if (lvl === 0) return 'Not purchased.';
      if (lvl === 1) return '9s cd. Bypass 1 obstacle.';
      if (lvl === 2) return '13s cd. Bypass 2 obstacles.';
      if (lvl === 3) return '16s cd. Bypass 3 obstacles + holes.';
    }
  };
  const JUMP_UPGRADE = {
    costs: [20, 60],
    highScoreRequirement: [400, 650],
    maxLevels: [2, 3],
    maxLevel: 2,
    effect: (lvl) => {
      if (lvl === 0) return 'Single jump.';
      if (lvl === 1) return 'Double jump.';
      if (lvl === 2) return 'Triple jump.';
    }
  };
  const MAGNET_UPGRADE = {
    costs: [40, 80],
    highScoreRequirement: [300, 800],
    values: [2, 3],
    radii: [150, 300],
    maxLevel: 2,
    effect: (lvl) => {
      if (lvl === 0) return 'No magnet. Coins = 1.';
      if (lvl === 1) return 'Magnet medium. Coins = 2.';
      if (lvl === 2) return 'Magnet strong. Coins = 3.';
    }
  };
  const UPGRADES = { time: TIME_UPGRADE, hacker: HACKER_UPGRADE, jump: JUMP_UPGRADE, magnet: MAGNET_UPGRADE };

  function buyUpgrade(name) {
    const upgrade = UPGRADES[name];
    const currentLevel = getUpgradeLevel(name);
    if (currentLevel >= upgrade.maxLevel) return;
    const cost = upgrade.costs[currentLevel];
    const requiredScore = upgrade.highScoreRequirement[currentLevel];
    if (requiredScore > 0 && highScore < requiredScore) return alert(`High Score of ${requiredScore} required.`);
    if (playerCoins < cost) return alert('Not enough coins.');
    playerCoins -= cost;
    setUpgradeLevel(name, currentLevel + 1);
    coinCountElement.textContent = playerCoins;
    updateShopUI();
    persistUserData();
    if (name === 'hacker') updateHackerButtonUI();
    if (name === 'time') updateTimeButtonUI();
  }
  function getUpgradeLevel(name) { return { time:timeLevel, hacker:hackerLevel, jump:jumpLevel, magnet:magnetLevel }[name] ?? 0; }
  function setUpgradeLevel(name, lvl) { if (name==='time') timeLevel=lvl; if(name==='hacker') hackerLevel=lvl; if(name==='jump') jumpLevel=lvl; if(name==='magnet') magnetLevel=lvl; }

  function updateShopUI() {
    // Upgrades UI
    ['time','hacker','jump','magnet'].forEach(key => {
      const upgrade = UPGRADES[key];
      const lvl = getUpgradeLevel(key);
      const levelEl = document.getElementById(`${key}-level`);
      const effectEl = document.getElementById(`${key}-effect`);
      const reqEl = document.getElementById(`${key}-req`);
      const costEl = document.getElementById(`${key}-cost`);
      const btn = document.getElementById(`buy-${key}-button`);
      if (!levelEl) return;
      levelEl.textContent = lvl;
      effectEl.textContent = upgrade.effect(lvl);
      if (lvl < upgrade.maxLevel) {
        const cost = upgrade.costs[lvl];
        const req = upgrade.highScoreRequirement[lvl];
        costEl.textContent = `Cost: ${cost} Coins`;
        reqEl.textContent = req > 0 ? `Required High Score: ${req}` : 'No High Score requirement.';
        btn.disabled = playerCoins < cost || (req > 0 && highScore < req);
        btn.textContent = btn.disabled ? (playerCoins < cost ? 'Not Enough Coins' : 'Score Too Low') : `Buy Level ${lvl+1}`;
      } else {
        costEl.textContent = 'MAX LEVEL';
        reqEl.textContent = 'You have maxed out this upgrade.';
        btn.disabled = true;
        btn.textContent = 'MAXED';
      }
    });

    // Skins UI
    shopCoinCountElement.textContent = playerCoins;
    shopHighScoreElement.textContent = highScore;
    ['santa','ninja','robot','pirate','rainbow'].forEach(k => {
      const el = document.getElementById(`${k}-owned`);
      if (el) el.textContent = ownedSkins[k] ? 'Yes' : 'No';
    });
    document.getElementById('equipped-skin').textContent = equippedSkin;
    equippedDisplay.textContent = equippedSkin;
  }

  // Skins buy/equip
  function buySkin(name) {
    if (name !== 'default' && ownedSkins[name]) return alert('Already owned.');
    const cost = skinCosts[name] || 0;
    if (playerCoins < cost) return alert('Not enough coins.');
    playerCoins -= cost;
    ownedSkins[name] = true;
    coinCountElement.textContent = playerCoins;
    updateShopUI();
    persistUserData();
  }
  function equipSkin(name) {
    if (name !== 'default' && !ownedSkins[name]) return alert('Skin not owned.');
    equippedSkin = name;
    document.getElementById('equipped-skin').textContent = equippedSkin;
    equippedDisplay.textContent = equippedSkin;
    if (player) player.setSkin(equippedSkin);
    persistUserData();
  }

  // =========================
  // Active abilities
  // =========================
  function activateHackerAbility() {
    if (hackerLevel === 0 || !isHackerAbilityReady || isGameOver) return;
    isHackerAbilityReady = false;
    hackerCooldownRemaining = HACKER_UPGRADE.cooldowns[hackerLevel-1];

    let bypassCount = hackerLevel === 1 ? 1 : (hackerLevel === 2 ? 2 : 3);
    let targets = obstacles.filter(obs => obs.x > player.x && !obs.isBypassed);
    if (hackerLevel === 3) targets = targets.concat(holes.filter(h => h.x > player.x));

    for (let i = 0; i < bypassCount && i < targets.length; i++) {
      const t = targets[i];
      if (t instanceof Obstacle) { t.isBypassed = true; t.color = '#059669'; }
      else if (t instanceof Hole) { t.color = '#34d399'; }
    }
    updateHackerButtonUI();
  }
  function activateTimeAbility() {
    if (timeLevel === 0 || !isTimeAbilityReady || isGameOver) return;
    isTimeAbilityReady = false;
    timeCooldownRemaining = TIME_UPGRADE.cooldowns[timeLevel-1];
    const factor = TIME_UPGRADE.slowdownFactor[timeLevel-1];
    currentSpeed = factor === 'BASE' ? 4.0 : currentSpeed * factor;
    timeEffectRemaining = TIME_UPGRADE.effectDuration[timeLevel-1];
    canvas.style.borderColor = '#60a5fa';
    updateTimeButtonUI();
  }
  function updateHackerButtonUI() {
    if (hackerLevel === 0) {
      hackerButton.disabled = true;
      hackerCooldownText.textContent = 'BUY IN SHOP';
      hackerCooldownOverlay.style.height = '100%';
      return;
    }
    if (isHackerAbilityReady) {
      hackerButton.disabled = false;
      hackerCooldownText.textContent = 'READY (X)';
      hackerCooldownOverlay.style.height = '0%';
    } else {
      hackerButton.disabled = true;
      const total = HACKER_UPGRADE.cooldowns[hackerLevel-1];
      const remainingSec = Math.ceil(hackerCooldownRemaining/1000);
      const percent = (hackerCooldownRemaining/total)*100;
      hackerCooldownText.textContent = `${remainingSec}s`;
      hackerCooldownOverlay.style.height = `${percent}%`;
    }
  }
  function updateTimeButtonUI() {
    if (timeLevel === 0) {
      timeButton.disabled = true;
      timeCooldownText.textContent = 'BUY IN SHOP';
      timeCooldownOverlay.style.height = '100%';
      return;
    }
    if (timeEffectRemaining > 0) {
      timeButton.disabled = true;
      timeCooldownText.textContent = `WARP: ${Math.ceil(timeEffectRemaining/1000)}s`;
      timeCooldownOverlay.style.height = '0%';
      return;
    }
    if (isTimeAbilityReady) {
      timeButton.disabled = false;
      timeCooldownText.textContent = 'READY (T)';
      timeCooldownOverlay.style.height = '0%';
    } else {
      timeButton.disabled = true;
      const total = TIME_UPGRADE.cooldowns[timeLevel-1];
      const remainingSec = Math.ceil(timeCooldownRemaining/1000);
      const percent = (timeCooldownRemaining/total)*100;
      timeCooldownText.textContent = `${remainingSec}s`;
      timeCooldownOverlay.style.height = `${percent}%`;
    }
  }

  // =========================
  // Player (small, animated running/jumping)
  // =========================
  class Player {
    constructor() {
      this.width = PLAYER_SIZE / 2;
      this.height = PLAYER_SIZE;
      this.x = 50;
      this.y = canvas.height - GROUND_HEIGHT - this.height;
      this.velocityY = 0;
      this.isCrouching = false;
      this.skin = equippedSkin;
      this.jumpCount = 0;
    }
    setSkin(s) { this.skin = s; }
    crouch(on) {
      this.isCrouching = on;
      this.height = on ? PLAYER_SIZE/2 : PLAYER_SIZE;
      this.y = canvas.height - GROUND_HEIGHT - this.height;
    }
    maxJumps() { return jumpLevel === 0 ? 1 : (jumpLevel === 1 ? 2 : 3); }
    jump() {
      if (isGameOver || this.isCrouching) return;
      const onGround = this.y >= canvas.height - GROUND_HEIGHT - this.height - 0.5;
      if (onGround) this.jumpCount = 0;
      if (this.jumpCount < this.maxJumps()) {
        this.velocityY = -9.5; // tuned for small size
        this.jumpCount++;
      }
    }
    draw() {
      ctx.lineWidth = 3; ctx.lineCap = 'round';

      // Skin color
      switch (this.skin) {
        case 'santa': ctx.strokeStyle = '#ff0000'; break;
        case 'ninja': ctx.strokeStyle = '#111111'; break;
        case 'robot': ctx.strokeStyle = '#9aa0a6'; break;
        case 'pirate': ctx.strokeStyle = '#8b5a2b'; break;
        case 'rainbow': {
          const g = ctx.createLinearGradient(this.x, this.y - 16, this.x, this.y + 32);
          g.addColorStop(0,'red'); g.addColorStop(0.2,'orange'); g.addColorStop(0.4,'yellow'); g.addColorStop(0.6,'green'); g.addColorStop(0.8,'blue'); g.addColorStop(1,'violet');
          ctx.strokeStyle = g; break;
        }
        default: ctx.strokeStyle = '#ffffff';
      }

      const cx = this.x + this.width/2;
      const headY = this.y - 7;
      const bodyTop = this.y;
      const bodyBottom = this.isCrouching ? this.y + 14 : this.y + 18;

      // Determine pose
      const onGround = this.y >= canvas.height - GROUND_HEIGHT - this.height - 0.5;
      const runPhase = Math.floor((performance.now()/120)) % 2; // simple alternating cadence

      // Head (small, smiling)
      ctx.beginPath(); ctx.arc(cx, headY, 7, 0, Math.PI*2); ctx.stroke();
      // Smile
      ctx.beginPath(); ctx.arc(cx, headY+2, 3, 0, Math.PI, false); ctx.stroke();

      // Body
      ctx.beginPath(); ctx.moveTo(cx, bodyTop); ctx.lineTo(cx, bodyBottom); ctx.stroke();

      // Arms: swing while running, up while jumping
      ctx.beginPath();
      if (onGround) {
        if (runPhase === 0) {
          ctx.moveTo(cx, this.y + 6); ctx.lineTo(this.x - 8, this.y + 10); // left back
          ctx.moveTo(cx, this.y + 6); ctx.lineTo(this.x + this.width + 10, this.y + 8); // right forward
        } else {
          ctx.moveTo(cx, this.y + 6); ctx.lineTo(this.x - 10, this.y + 8); // left forward
          ctx.moveTo(cx, this.y + 6); ctx.lineTo(this.x + this.width + 8, this.y + 10); // right back
        }
      } else {
        // jump: arms up
        ctx.moveTo(cx, this.y + 4); ctx.lineTo(this.x - 8, this.y - 4);
        ctx.moveTo(cx, this.y + 4); ctx.lineTo(this.x + this.width + 8, this.y - 4);
      }
      ctx.stroke();

      // Legs: alternating run vs compact jump tuck
      ctx.beginPath();
      if (onGround) {
        if (runPhase === 0) {
          ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x - 6, this.y + this.height);       // left extended
          ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x + this.width + 6, this.y + this.height - 4); // right pushing
        } else {
          ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x - 6, this.y + this.height - 4);   // left pushing
          ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x + this.width + 6, this.y + this.height);     // right extended
        }
      } else {
        // jump pose: both legs angled upward
        ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x - 4, this.y + this.height - 8);
        ctx.moveTo(cx, bodyBottom); ctx.lineTo(this.x + this.width + 4, this.y + this.height - 8);
      }
      ctx.stroke();

      // Accessories (simplified to fit small size)
      switch (this.skin) {
        case 'santa':
          ctx.fillStyle = '#ffffff'; ctx.fillRect(cx - 10, headY - 9, 20, 3);
          ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(cx - 10, headY - 9); ctx.lineTo(cx + 10, headY - 9); ctx.lineTo(cx, headY - 22); ctx.closePath(); ctx.fill();
          break;
        case 'robot':
          ctx.strokeStyle = '#9aa0a6'; ctx.beginPath(); ctx.moveTo(cx, headY - 7); ctx.lineTo(cx, headY - 12); ctx.stroke();
          ctx.fillStyle = '#64b5f6'; ctx.beginPath(); ctx.arc(cx, headY - 12, 2.5, 0, Math.PI*2); ctx.fill();
          break;
      }
    }
  }

  // =========================
  // Entities
  // =========================
  class Obstacle {
    constructor(type) {
      this.type = type;
      this.width = 18 + Math.random()*18;
      this.isBypassed = false;
      if (type === 'ground') {
        this.height = 16 + Math.random()*26;
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT - this.height;
        this.color = '#ff6b6b';
      } else {
        this.height = 13;
        this.width = 36 + Math.random()*26;
        this.x = canvas.width;
        this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE*2.5 - Math.random()*50;
        this.color = '#647DEE';
        this.vy = 0.28;
      }
    }
    update() {
      this.x -= currentSpeed;
      if (this.type === 'air' && Math.floor(score/10) >= 250) this.y += this.vy;
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      if (this.type === 'ground' && !this.isBypassed) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(this.x, canvas.height - GROUND_HEIGHT, this.width, 10);
      }
    }
  }

  class Hole {
    constructor() {
      this.width = 70 + Math.random()*70;
      this.x = canvas.width;
      this.y = canvas.height - GROUND_HEIGHT;
      this.height = GROUND_HEIGHT;
      this.color = '#16213e';
    }
    update() { this.x -= currentSpeed; }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.strokeStyle = '#0f172a';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y); ctx.stroke();
    }
  }

  class Trap {
    constructor() {
      this.width = 38 + Math.random()*18;
      this.x = canvas.width;
      this.y = canvas.height - GROUND_HEIGHT;
      this.height = GROUND_HEIGHT;
      this.isTriggered = false;
      this.animationProgress = 0;
      this.baseColor = '#2f2b2d';
    }
    update() {
      this.x -= currentSpeed;
      if (this.isTriggered && this.animationProgress < 1) this.animationProgress += 0.06;
    }
    draw() {
      ctx.fillStyle = this.baseColor;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      if (this.isTriggered) {
        const jawLen = 22, jawWidth = 6;
        const baseX = this.x + this.width/2, baseY = this.y;

        ctx.save();
        ctx.translate(baseX - 10, baseY);
        ctx.rotate(-Math.PI/2 * this.animationProgress);
        ctx.fillStyle = '#a10000';
        ctx.fillRect(-jawWidth/2, -jawLen, jawWidth, jawLen);
        ctx.restore();

        ctx.save();
        ctx.translate(baseX + 10, baseY);
        ctx.rotate(Math.PI/2 * this.animationProgress);
        ctx.fillStyle = '#a10000';
        ctx.fillRect(-jawWidth/2, -jawLen, jawWidth, jawLen);
        ctx.restore();
      }
    }
  }

  class Coin {
    constructor() {
      this.size = 13;
      this.x = canvas.width;
      const level = Math.floor(Math.random()*3);
      if (level === 0) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE*3.5;
      else if (level === 1) this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE*1.5;
      else this.y = canvas.height - GROUND_HEIGHT - PLAYER_SIZE*0.5;
      this.color = '#FFD700';
    }
    update() { this.x -= currentSpeed; }
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // =========================
  // Input
  // =========================
  function handleInput() {
    document.addEventListener('keydown', (e) => {
      if (isGameOver) return;
      if (e.code === 'Space' || e.code === 'Enter') player.jump();
      if (e.key === 'ArrowDown' || e.key === 's') player.crouch(true);
      if (e.key === 'x' || e.key === 'X') activateHackerAbility();
      if (e.key === 't' || e.key === 'T') activateTimeAbility();
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown' || e.key === 's') player.crouch(false);
    });

    document.getElementById('jump-button').addEventListener('click', () => { if (!isGameOver) player.jump(); });
    const crouchBtn = document.getElementById('crouch-button');
    crouchBtn.addEventListener('mousedown', () => player.crouch(true));
    crouchBtn.addEventListener('mouseup', () => player.crouch(false));
    crouchBtn.addEventListener('mouseleave', () => player.crouch(false));
    crouchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); player.crouch(true); });
    crouchBtn.addEventListener('touchend', (e) => { e.preventDefault(); player.crouch(false); });

    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isGameOver) player.jump(); });
    window.addEventListener('mouseup', () => player?.crouch(false));
    window.addEventListener('touchend', () => player?.crouch(false));
  }

  // =========================
  // Game loop
  // =========================
  function startGame() {
    stopGame();
    score = 0;
    obstacles = []; holes = []; traps = []; coins = [];
    isGameOver = false;
    obstacleSpawnTimer = 0; coinSpawnTimer = 0;
    currentSpeed = 4.0;

    // reset abilities
    isHackerAbilityReady = true; hackerCooldownRemaining = 0;
    isTimeAbilityReady = true; timeCooldownRemaining = 0; timeEffectRemaining = 0;

    updateHackerButtonUI();
    updateTimeButtonUI();

    player = new Player();
    player.setSkin(equippedSkin);
    gameOverModal.style.display = 'none';
    canvas.style.borderColor = '#e94560';

    // Lag fix: initialize lastTime to current time
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
  }
  function stopGame() {
    if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
    persistUserData();
  }

  function gameLoop(currentTime) {
    const deltaTime = Math.min(currentTime - lastTime, 100);
    lastTime = currentTime;
    if (isGameOver) { stopGame(); return; }
    update(deltaTime);
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function update(deltaTime) {
    // Score & speed
    score += deltaTime / 16;
    const uiScore = Math.floor(score / 10);
    scoreElement.textContent = uiScore;

    const speedFactor = Math.min(uiScore / maxScoreForSpeed, 1);
    const calculatedSpeed = 4.0 + maxSpeedIncrease * speedFactor;
    if (timeEffectRemaining <= 0) { currentSpeed = calculatedSpeed; canvas.style.borderColor = '#e94560'; }

    // Ability timers
    if (hackerCooldownRemaining > 0) {
      hackerCooldownRemaining -= deltaTime;
      if (hackerCooldownRemaining <= 0) { hackerCooldownRemaining = 0; isHackerAbilityReady = true; }
      updateHackerButtonUI();
    }
    if (timeCooldownRemaining > 0) {
      timeCooldownRemaining -= deltaTime;
      if (timeCooldownRemaining <= 0) { timeCooldownRemaining = 0; isTimeAbilityReady = true; }
      updateTimeButtonUI();
    }
    if (timeEffectRemaining > 0) {
      timeEffectRemaining -= deltaTime;
      if (timeEffectRemaining <= 0) { timeEffectRemaining = 0; currentSpeed = calculatedSpeed; }
      updateTimeButtonUI();
    }

    // Physics
    const groundY = canvas.height - GROUND_HEIGHT - player.height;
    player.velocityY += 0.6;
    player.y += player.velocityY;
    if (player.y >= groundY) {
      player.y = groundY; player.velocityY = 0; player.jumpCount = 0;
    }

    // Difficulty curve
    const initialRate = 100;
    const difficultyFactor = Math.min(uiScore / 300, 1);
    obstacleSpawnRate = initialRate - (initialRate - minObstacleRate) * difficultyFactor;

    // Spawns (lag fix: start after score threshold)
    if (uiScore > START_SPAWN_SCORE) {
      obstacleSpawnTimer++;
      if (obstacleSpawnTimer >= obstacleSpawnRate) {
        if (Math.random() < 0.15) holes.push(new Hole());
        else obstacles.push(new Obstacle(Math.random() < 0.7 ? 'ground' : 'air'));
        obstacleSpawnTimer = 0;
      }

      coinSpawnTimer++;
      if (coinSpawnTimer >= COIN_SPAWN_RATE) {
        if (Math.random() < 0.6) coins.push(new Coin());
        coinSpawnTimer = 0;
      }
    }

    // Traps start later
    if (uiScore >= 200 && Math.random() < 0.02) traps.push(new Trap());

    // Magnet attraction
    if (magnetLevel > 0) {
      const radius = MAGNET_UPGRADE.radii[magnetLevel - 1];
      coins.forEach(coin => {
        const dx = (player.x + player.width / 2) - (coin.x + coin.size / 2);
        const dy = (player.y + player.height / 2) - (coin.y + coin.size / 2);
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < radius) {
          const ax = dx / Math.max(dist, 1) * 0.02;
          const ay = dy / Math.max(dist, 1) * 0.02;
          coin.x += ax * deltaTime;
          coin.y += ay * deltaTime;
        }
      });
    }

    // Update entities
    obstacles.forEach(o => o.update());
    holes.forEach(h => h.update());
    traps.forEach(t => t.update());
    coins.forEach(c => c.update());

    // Cleanup
    obstacles = obstacles.filter(o => o.x + o.width >= 0);
    holes = holes.filter(h => h.x + h.width >= 0);
    traps = traps.filter(t => t.x + t.width >= 0);
    coins = coins.filter(c => c.x + c.size >= 0);

    // Collisions
    for (const obs of obstacles) {
      if (rectsOverlap(player.x, player.y, player.width, player.height, obs.x, obs.y, obs.width, obs.height)) {
        return gameOver();
      }
    }
    for (const hole of holes) {
      const touchingGround = player.y + player.height >= canvas.height - GROUND_HEIGHT;
      const overX = (player.x + player.width) > hole.x && player.x < (hole.x + hole.width);
      if (touchingGround && overX) { return gameOver(); }
    }
    for (const trap of traps) {
      const overlap = rectsOverlap(player.x, player.y, player.width, player.height, trap.x, trap.y, trap.width, trap.height);
      if (!trap.isTriggered && overlap) { trap.isTriggered = true; return gameOver(); }
    }
    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      if (rectsOverlap(player.x, player.y, player.width, player.height, c.x, c.y, c.size, c.size)) {
        let value = 1;
        if (magnetLevel === 1) value = MAGNET_UPGRADE.values[0];
        if (magnetLevel === 2) value = MAGNET_UPGRADE.values[1];
        playerCoins += value;
        coinCountElement.textContent = playerCoins;
        coins.splice(i, 1);
        persistUserData();
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Ground
    ctx.fillStyle = '#2d3748';
    ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

    holes.forEach(h => h.draw());
    traps.forEach(t => t.draw());
    obstacles.forEach(o => o.draw());
    coins.forEach(c => c.draw());
    player.draw();
  }

  function gameOver() {
    isGameOver = true;
    const finalScore = Math.floor(score / 10);
    finalScoreElement.textContent = finalScore;
    if (finalScore > highScore) {
      highScore = finalScore;
      highScoreElement.textContent = highScore;
    }
    gameOverModal.style.display = 'flex';
    persistUserData();
  }

  // Utils
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }
  function resizeCanvas() {
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    if (player) {
      const groundY = canvas.height - GROUND_HEIGHT - player.height;
      if (player.y > groundY) player.y = groundY;
    }
    draw();
  }
  window.addEventListener('resize', () => { if (currentScreen === 'game') resizeCanvas(); });

  // Input init
  handleInput();

  // Shop previews
  function renderPreviews() {
    drawPreview('preview-default', 'default');
    drawPreview('preview-santa', 'santa');
    drawPreview('preview-ninja', 'ninja');
    drawPreview('preview-robot', 'robot');
    drawPreview('preview-pirate', 'pirate');
    drawPreview('preview-rainbow', 'rainbow');
  }
  function drawPreview(id,skin){
    const c=document.getElementById(id); if(!c) return;
    const p=c.getContext('2d');
    p.clearRect(0,0,c.width,c.height);
    const x=30,y=60,w=18,h=24; const cx=x+w/2;
    p.lineWidth=3;
    switch(skin){
      case 'santa': p.strokeStyle='#ff0000'; break;
      case 'ninja': p.strokeStyle='#111111'; break;
      case 'robot': p.strokeStyle='#9aa0a6'; break;
      case 'pirate': p.strokeStyle='#8b5a2b'; break;
      case 'rainbow': { const g=p.createLinearGradient(x,y-20,x,y+40); g.addColorStop(0,'red'); g.addColorStop(0.25,'orange'); g.addColorStop(0.5,'yellow'); g.addColorStop(0.75,'green'); g.addColorStop(1,'blue'); p.strokeStyle=g; break; }
      default: p.strokeStyle='#ffffff';
    }
    // Head
    p.beginPath(); p.arc(cx,y-9,7,0,Math.PI*2); p.stroke();
    // Body
    p.beginPath(); p.moveTo(cx,y); p.lineTo(cx,y+18); p.stroke();
    // Arms
    p.beginPath(); p.moveTo(cx,y+5); p.lineTo(x-7,y+9);
    p.moveTo(cx,y+5); p.lineTo(x+w+7,y+9); p.stroke();
    // Legs
    p.beginPath(); p.moveTo(cx,y+18); p.lineTo(x,y+h);
    p.moveTo(cx,y+18); p.lineTo(x+w,y+h); p.stroke();

    if(skin==='santa'){ p.fillStyle='#fff'; p.fillRect(cx-11,y-16,22,3); p.fillStyle='#ff0000'; p.beginPath(); p.moveTo(cx-11,y-16); p.lineTo(cx+11,y-16); p.lineTo(cx,y-28); p.closePath(); p.fill(); }
    if(skin==='robot'){ p.strokeStyle='#9aa0a6'; p.beginPath(); p.moveTo(cx,y-14); p.lineTo(cx,y-20); p.stroke(); p.fillStyle='#64b5f6'; p.beginPath(); p.arc(cx,y-20,3,0,Math.PI*2); p.fill(); }
  }
</script>
</body>
</html>
